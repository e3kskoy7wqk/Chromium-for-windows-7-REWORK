diff --git a/gpu/config/gpu_info_collector_win.cc b/gpu/config/gpu_info_collector_win.cc
index fd4c295d1f38b..cb0230755c272 100644
--- a/gpu/config/gpu_info_collector_win.cc
+++ b/gpu/config/gpu_info_collector_win.cc
@@ -8,6 +8,11 @@
 #include "gpu/config/gpu_info_collector.h"
 
 // C system before C++ system.
+// This has to be included before windows.h.
+#include "third_party/re2/src/re2/re2.h"
+
+#include <windows.h>
+
 #include <DirectML.h>
 #include <d3d11.h>
 #include <d3d11_3.h>
@@ -27,7 +32,7 @@
 #include "gpu/config/gpu_util.h"
 #include "third_party/microsoft_dxheaders/src/include/directx/d3d12.h"
 #include "third_party/microsoft_dxheaders/src/include/directx/dxcore.h"
-#include "third_party/re2/src/re2/re2.h"
+#include "base/win/windows_version.h"
 #include "ui/gl/direct_composition_support.h"
 #include "ui/gl/gl_angle_util_win.h"
 #include "ui/gl/gl_display.h"
@@ -158,6 +163,20 @@ bool GetActiveAdapterLuid(LUID* luid) {
 
 }  // namespace
 
+#if BUILDFLAG(GOOGLE_CHROME_BRANDING) && defined(OFFICIAL_BUILD)
+// This function has a real implementation for official builds that can
+// be found in src/third_party/amd.
+bool GetAMDSwitchableInfo(bool* is_switchable,
+                          uint32_t* active_vendor_id,
+                          uint32_t* active_device_id);
+#else
+bool GetAMDSwitchableInfo(bool* is_switchable,
+                          uint32_t* active_vendor_id,
+                          uint32_t* active_device_id) {
+  return false;
+}
+#endif
+
 // This has to be called after a context is created, active GPU is identified,
 // and GPU driver bug workarounds are computed again. Otherwise the workaround
 // |disable_direct_composition| may not be correctly applied.
@@ -192,6 +211,10 @@ bool CollectDriverInfoD3D(GPUInfo* gpu_info) {
   if (FAILED(hr))
     return false;
 
+  bool found_amd = false;
+  bool found_intel = false;
+  bool found_nvidia = false;
+
   UINT i;
   Microsoft::WRL::ComPtr<IDXGIAdapter> dxgi_adapter;
   for (i = 0; SUCCEEDED(dxgi_factory->EnumAdapters(i, &dxgi_adapter)); i++) {
@@ -218,6 +241,20 @@ bool CollectDriverInfoD3D(GPUInfo* gpu_info) {
       DLOG(ERROR) << "Unable to retrieve the umd version of adapter: "
                   << desc.Description << " HR: " << std::hex << hr;
     }
+    switch (device.vendor_id) {
+      case 0x8086:
+        found_intel = true;
+        break;
+      case 0x1002:
+        found_amd = true;
+        break;
+      case 0x10de:
+        found_nvidia = true;
+        break;
+      default:
+        break;
+    }
+
     if (i == 0) {
       gpu_info->gpu = device;
     } else {
@@ -225,6 +262,23 @@ bool CollectDriverInfoD3D(GPUInfo* gpu_info) {
     }
   }
 
+  if (found_intel && base::win::GetVersion() < base::win::Version::WIN10) {
+    // Since Windows 10 (and Windows 8.1 on some systems), switchable graphics
+    // platforms are managed by Windows and each adapter is accessible as
+    // separate devices.
+    // See https://msdn.microsoft.com/en-us/windows/dn265501(v=vs.80)
+    if (found_amd) {
+      bool is_amd_switchable = false;
+      uint32_t active_vendor = 0, active_device = 0;
+      GetAMDSwitchableInfo(&is_amd_switchable, &active_vendor, &active_device);
+      gpu_info->amd_switchable = is_amd_switchable;
+    } else if (found_nvidia) {
+      // nvd3d9wrap.dll is loaded into all processes when Optimus is enabled.
+      HMODULE nvd3d9wrap = GetModuleHandleW(L"nvd3d9wrap.dll");
+      gpu_info->optimus = nvd3d9wrap != nullptr;
+    }
+  }
+
   Microsoft::WRL::ComPtr<IDXGIFactory6> dxgi_factory6;
   if (gpu_info->GpuCount() > 1 && SUCCEEDED(dxgi_factory.As(&dxgi_factory6))) {
     if (SUCCEEDED(dxgi_factory6->EnumAdapterByGpuPreference(
@@ -487,6 +541,7 @@ bool InitVulkanInstanceProc(
     PFN_vkEnumeratePhysicalDevices* vkEnumeratePhysicalDevices,
     PFN_vkEnumerateDeviceExtensionProperties*
         vkEnumerateDeviceExtensionProperties) {
+
   *vkEnumeratePhysicalDevices =
       reinterpret_cast<PFN_vkEnumeratePhysicalDevices>(
           vkGetInstanceProcAddr(vk_instance, "vkEnumeratePhysicalDevices"));
diff --git a/gpu/ipc/service/gpu_watchdog_thread.cc b/gpu/ipc/service/gpu_watchdog_thread.cc
index 7dfca75187822..38d1d946d0b71 100644
--- a/gpu/ipc/service/gpu_watchdog_thread.cc
+++ b/gpu/ipc/service/gpu_watchdog_thread.cc
@@ -34,6 +30,10 @@
 #include <windows.h>
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace gpu {
 
 base::TimeDelta GetGpuWatchdogTimeout(bool software_rendering) {
@@ -50,11 +50,12 @@ base::TimeDelta GetGpuWatchdogTimeout() {
 
   base::TimeDelta timeout = kGpuWatchdogTimeout;
 #if BUILDFLAG(IS_WIN)
-  int num_of_processors = base::SysInfo::NumberOfProcessors();
-  if (num_of_processors > 8) {
-    timeout -= base::Seconds(10);
-  } else if (num_of_processors <= 4) {
-    timeout += base::Seconds(5);
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    int num_of_processors = base::SysInfo::NumberOfProcessors();
+    if (num_of_processors > 8)
+      timeout -= base::Seconds(10);
+    else if (num_of_processors <= 4)
+      timeout += base::Seconds(5);
   }
 #endif
 
