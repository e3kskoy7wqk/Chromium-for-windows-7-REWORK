diff --git a/sandbox/win/src/handle_closer_agent.cc b/sandbox/win/src/handle_closer_agent.cc
index b66c169e25dc4..7c31bed321732 100644
--- a/sandbox/win/src/handle_closer_agent.cc
+++ b/sandbox/win/src/handle_closer_agent.cc
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/win/static_constants.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/heap_helper.h"
 #include "sandbox/win/src/sandbox_nt_util.h"
 #include "sandbox/win/src/win_utils.h"
@@ -150,6 +151,12 @@ bool HandleCloserAgent::CloseHandles() {
     return false;
   }
 
+  if (base::win::GetVersion() < base::win::Version::WIN8_1) {
+    if (!GetCurrentProcessHandlesWin7())
+      return false;
+    return true;
+  }
+
   // The system call will return only handles up to the buffer size so add a
   // margin of error of an additional 1000 handles.
   auto handles = base::HeapArray<uint32_t>::WithSize(handle_count + 1000);
diff --git a/sandbox/win/src/win_utils.cc b/sandbox/win/src/win_utils.cc
index 0ef8ad4747035..03b7178538d41 100644
--- a/sandbox/win/src/win_utils.cc
+++ b/sandbox/win/src/win_utils.cc
@@ -573,6 +573,36 @@ absl::optional<ProcessHandleMap> GetCurrentProcessHandles() {
   return base_address;
 }
 
+std::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7() {
+  DWORD handle_count = UINT_MAX;
+  const int kInvalidHandleThreshold = 100;
+  const size_t kHandleOffset = 4;  // Handles are always a multiple of 4.
+
+  if (!::GetProcessHandleCount(::GetCurrentProcess(), &handle_count))
+    return std::nullopt;
+  ProcessHandleMap handle_map;
+
+  uint32_t handle_value = 0;
+  int invalid_count = 0;
+
+  // Keep incrementing until we hit the number of handles reported by
+  // GetProcessHandleCount(). If we hit a very long sequence of invalid
+  // handles we assume that we've run past the end of the table.
+  while (handle_count && invalid_count < kInvalidHandleThreshold) {
+    handle_value += kHandleOffset;
+    HANDLE handle = base::win::Uint32ToHandle(handle_value);
+    auto type_name = GetTypeNameFromHandle(handle);
+    if (!type_name) {
+      ++invalid_count;
+      continue;
+    }
+
+    --handle_count;
+    handle_map[type_name.value()].push_back(handle);
+  }
+  return handle_map;
+}
+
 bool ContainsNulCharacter(std::wstring_view str) {
   wchar_t nul = '\0';
   return str.find_first_of(nul) != std::wstring::npos;
diff --git a/sandbox/win/src/win_utils.h b/sandbox/win/src/win_utils.h
index fafc6b7248355..fbc98221c3ff8 100644
--- a/sandbox/win/src/win_utils.h
+++ b/sandbox/win/src/win_utils.h
@@ -8,10 +8,12 @@
 #include <stdint.h>
 #include <stdlib.h>
 
+#include <map>
 #include <memory>
 #include <optional>
 #include <string>
 #include <string_view>
+#include <vector>
 
 #include "base/containers/span.h"
 #include "base/win/windows_types.h"
@@ -21,6 +23,9 @@ namespace sandbox {
 // Prefix for path used by NT calls.
 const wchar_t kNTPrefix[] = L"\\??\\";
 
+// List of handles mapped to their kernel object type name.
+using ProcessHandleMap = std::map<std::wstring, std::vector<HANDLE>>;
+
 // Basic implementation of a singleton which calls the destructor
 // when the exe is shutting down or the DLL is being unloaded.
 template <typename Derived>
@@ -123,6 +123,11 @@ void* GetProcessBaseAddress(HANDLE process);
 // the base address. This should only be called on new, suspended processes.
 void* GetProcessBaseAddress(HANDLE process);
 
+// Fallback function for GetCurrentProcessHandles. Should only be needed on
+// Windows 7 which doesn't support the API to query all process handles. This
+// uses a brute force method to get the process handles.
+std::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7();
+
 // Returns true if the string contains a NUL ('\0') character.
 bool ContainsNulCharacter(std::wstring_view str);
 
