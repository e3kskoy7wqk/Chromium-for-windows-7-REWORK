diff --git a/third_party/libc++/src/src/support/win32/thread_win32.cpp b/third_party/libc++/src/src/support/win32/thread_win32.cpp
index 3ca36df80..cdc5e594c 100644
--- a/third_party/libc++/src/src/support/win32/thread_win32.cpp
+++ b/third_party/libc++/src/src/support/win32/thread_win32.cpp
@@ -67,15 +67,430 @@ int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m)
   return 0;
 }
 
+//
+// Push lock definitions
+//
+typedef struct _EX_PUSH_LOCK {
+
+#define EX_PUSH_LOCK_WAITING   0x1
+#define EX_PUSH_LOCK_EXCLUSIVE 0x2
+#define EX_PUSH_LOCK_SHARE_INC 0x4
+
+    union {
+        struct {
+            ULONG_PTR Waiting : 1;
+            ULONG_PTR Exclusive : 1;
+            ULONG_PTR Shared : sizeof (ULONG_PTR) * 8 - 2;
+        };
+        ULONG_PTR Value;
+        PVOID Ptr;
+    };
+} EX_PUSH_LOCK, *PEX_PUSH_LOCK;
+
+
+//
+// This is a block held on the local stack of the waiting threads.
+//
+
+typedef  struct _EX_PUSH_LOCK_WAIT_BLOCK *PEX_PUSH_LOCK_WAIT_BLOCK;
+
+typedef struct _EX_PUSH_LOCK_WAIT_BLOCK {
+    HANDLE WakeEvent;
+    PEX_PUSH_LOCK_WAIT_BLOCK Next;
+    PEX_PUSH_LOCK_WAIT_BLOCK Last;
+    PEX_PUSH_LOCK_WAIT_BLOCK Previous;
+    ULONG ShareCount;
+    BOOLEAN Exclusive;
+} EX_PUSH_LOCK_WAIT_BLOCK;
+
+#define ASSERT(x)
+
+static
+VOID
+ExfAcquirePushLockExclusive (
+     IN PEX_PUSH_LOCK PushLock
+     )
+/*++
+
+Routine Description:
+
+    Acquire a push lock exclusively
+
+Arguments:
+
+    PushLock - Push lock to be acquired
+
+Return Value:
+
+    None
+
+--*/
+{
+    EX_PUSH_LOCK OldValue, NewValue;
+    EX_PUSH_LOCK_WAIT_BLOCK WaitBlock;
+
+    OldValue = *PushLock;
+    while (1) {
+        //
+        // If the lock is already held exclusively/shared or there are waiters then
+        // we need to wait.
+        //
+        if (OldValue.Value == 0) {
+            NewValue.Value = OldValue.Value + EX_PUSH_LOCK_EXCLUSIVE;
+            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                                              NewValue.Ptr,
+                                                              OldValue.Ptr);
+            if (NewValue.Ptr == OldValue.Ptr) {
+                break;
+            }
+        } else {
+            WaitBlock.WakeEvent = CreateEvent ( NULL, FALSE, FALSE, NULL );
+            WaitBlock.Exclusive = TRUE;
+            WaitBlock.Last = NULL;
+            WaitBlock.Previous = NULL;
+            //
+            // Move the sharecount to our wait block if need be.
+            //
+            if (OldValue.Waiting) {
+                WaitBlock.Next = (PEX_PUSH_LOCK_WAIT_BLOCK)
+                                     (OldValue.Value - EX_PUSH_LOCK_WAITING);
+                WaitBlock.ShareCount = 0;
+            } else {
+                WaitBlock.Next = NULL;
+                WaitBlock.ShareCount = (ULONG) OldValue.Shared;
+            }
+            NewValue.Ptr = ((PUCHAR) &WaitBlock) + EX_PUSH_LOCK_WAITING;
+            ASSERT ((NewValue.Value & EX_PUSH_LOCK_WAITING) != 0);
+            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                                              NewValue.Ptr,
+                                                              OldValue.Ptr);
+            if (NewValue.Ptr == OldValue.Ptr) {
+                WaitForSingleObject(WaitBlock.WakeEvent, INFINITE);
+                ASSERT ((WaitBlock.ShareCount == 0) && (WaitBlock.Next == NULL));
+                CloseHandle(WaitBlock.WakeEvent);
+                break;
+            }
+            CloseHandle(WaitBlock.WakeEvent);
+
+        }
+        OldValue = NewValue;
+    }
+}
+
+static
+VOID
+ExfReleasePushLock (
+     IN PEX_PUSH_LOCK PushLock
+     )
+/*++
+
+Routine Description:
+
+    Release a push lock that was acquired exclusively or shared
+
+Arguments:
+
+    PushLock - Push lock to be released
+
+Return Value:
+
+    None
+
+--*/
+{
+    EX_PUSH_LOCK OldValue, NewValue;
+    PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock, NextWaitBlock, ReleaseWaitList, Previous;
+    PEX_PUSH_LOCK_WAIT_BLOCK LastWaitBlock, FirstWaitBlock;
+    ULONG ShareCount;
+#if 0
+    KIRQL OldIrql;
+#endif
+
+    OldValue = *PushLock;
+    while (1) {
+        if (!OldValue.Waiting) {
+            //
+            // Either we hold the lock exclusive or shared but not both.
+            //
+            ASSERT (OldValue.Exclusive ^ (OldValue.Shared > 0));
+
+            //
+            // We must hold the lock exclusive or shared. We make the assuption that
+            // the exclusive bit is just below the share count here.
+            //
+            NewValue.Value = (OldValue.Value - EX_PUSH_LOCK_EXCLUSIVE) &
+                             ~EX_PUSH_LOCK_EXCLUSIVE;
+            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                                              NewValue.Ptr,
+                                                              OldValue.Ptr);
+            if (NewValue.Ptr == OldValue.Ptr) {
+                break;
+            }
+            //
+            // Either we gained a new waiter or another shared owner arrived or left
+            //
+            ASSERT (NewValue.Waiting || (NewValue.Shared > 0 && !NewValue.Exclusive));
+            OldValue = NewValue;
+        } else {
+            //
+            // There are waiters chained to the lock. We have to release the share count,
+            // last exclusive or last chain of shared waiters.
+            //
+            WaitBlock = (PEX_PUSH_LOCK_WAIT_BLOCK)
+                           (OldValue.Value - EX_PUSH_LOCK_WAITING);
+
+            FirstWaitBlock = WaitBlock;
+            ReleaseWaitList = WaitBlock;
+            Previous = NULL;
+            LastWaitBlock = NULL;
+            ShareCount = 0;
+            do {
+
+                if (WaitBlock->Last != NULL) {
+                    LastWaitBlock = WaitBlock;
+                    WaitBlock = WaitBlock->Last;
+                    Previous = WaitBlock->Previous;
+                    ReleaseWaitList = WaitBlock;
+                    ASSERT (WaitBlock->Next == NULL);
+                    ASSERT (Previous != NULL);
+                    ShareCount = 0;
+                }
+
+                if (WaitBlock->Exclusive) {
+                    //
+                    // This is an exclusive waiter. If this was the first exclusive waited to a shared acquire
+                    // then it will have the saved share count. If we acquired the lock shared then the count
+                    // must contain a bias for this thread. Release that and if we are not the last shared
+                    // accessor then exit. A later shared release thread will wake the exclusive
+                    // waiter.
+                    //
+                    if (WaitBlock->ShareCount != 0) {
+                        if (InterlockedDecrement ((PLONG)&WaitBlock->ShareCount) != 0) {
+                            return;
+                        }
+                    }
+                    //
+                    // Reset count of share acquires waiting.
+                    //
+                    ShareCount = 0;
+                } else {
+                    //
+                    // This is a shared waiter. Record the number of these to update the head or the
+                    // previous exclusive waiter.
+                    //
+                    ShareCount++;
+                }
+                NextWaitBlock = WaitBlock->Next;
+                if (NextWaitBlock != NULL) {
+
+                    NextWaitBlock->Previous = WaitBlock;
+
+                    if (NextWaitBlock->Exclusive) {
+                        //
+                        // The next block is exclusive. This may be the entry to free.
+                        //
+                        Previous = WaitBlock;
+                        ReleaseWaitList = NextWaitBlock;
+                    } else {
+                        //
+                        // The next block is shared. If the chain start is exclusive then skip to this one
+                        // as the exclusive isn't the thread we will wake up.
+                        //
+                        if (ReleaseWaitList->Exclusive) {
+                            Previous = WaitBlock;
+                            ReleaseWaitList = NextWaitBlock;
+                        }
+                    }
+                }
+
+                WaitBlock = NextWaitBlock;
+            } while (WaitBlock != NULL);
+
+            //
+            // If our release chain is everything then we have to update the header
+            //
+            if (Previous == NULL) {
+                NewValue.Value = 0;
+                NewValue.Exclusive = ReleaseWaitList->Exclusive;
+                NewValue.Shared = ShareCount;
+                ASSERT (((ShareCount > 0) ^ (ReleaseWaitList->Exclusive)) && !NewValue.Waiting);
+
+                NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                                                  NewValue.Ptr,
+                                                                  OldValue.Ptr);
+                if (NewValue.Ptr != OldValue.Ptr) {
+                    //
+                    // We are releasing so we could have only gained another waiter
+                    //
+                    ASSERT (NewValue.Waiting);
+                    OldValue = NewValue;
+                    continue;
+                }
+            } else {
+
+                if (LastWaitBlock != NULL) {
+                    LastWaitBlock->Last = NULL;
+                }
+                //
+                // Truncate the chain at this position and save the share count for all the shared owners to
+                // decrement later.
+                //
+                Previous->Next = NULL;
+                ASSERT (Previous->ShareCount == 0);
+                Previous->ShareCount = ShareCount;
+
+                //
+                // Add a pointer to make future searches faster
+                //
+                if (Previous->Exclusive && FirstWaitBlock != Previous) {
+                    FirstWaitBlock->Last = Previous;
+                    ASSERT (Previous->Previous != NULL);
+                }
+                //
+                // We are either releasing multiple share accessors or a single exclusive
+                //
+                ASSERT ((ShareCount > 0) ^ ReleaseWaitList->Exclusive);
+            }
+
+#if 0
+            //
+            // If we are waking more than one thread then raise to DPC level to prevent us
+            // getting rescheduled part way through the operation
+            //
+
+            OldIrql = DISPATCH_LEVEL;
+            if (ShareCount > 1) {
+                KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);
+            }
+#endif
+
+            //
+            //
+            // Release the chain of threads we located.
+            //
+            do {
+                NextWaitBlock = ReleaseWaitList->Next;
+                //
+                // All the chain should have the same type (Exclusive/Shared).
+                //
+                ASSERT (NextWaitBlock == NULL || (ReleaseWaitList->Exclusive == NextWaitBlock->Exclusive));
+                ASSERT (!ReleaseWaitList->Exclusive || (ReleaseWaitList->ShareCount == 0));
+#if 0
+                KeSetEventBoostPriority (&ReleaseWaitList->WakeEvent, NULL);
+#endif
+                SetEvent(ReleaseWaitList->WakeEvent);
+                ReleaseWaitList = NextWaitBlock;
+            } while (ReleaseWaitList != NULL);
+
+#if 0
+            if (OldIrql != DISPATCH_LEVEL) {
+                KeLowerIrql (OldIrql);
+            }
+#endif
+
+
+            break;
+        }
+    }
+}
+
+static
+VOID
+ExAcquirePushLockExclusive (
+     IN PEX_PUSH_LOCK PushLock
+     )
+/*++
+
+Routine Description:
+
+    Acquire a push lock exclusively
+
+Arguments:
+
+    PushLock - Push lock to be acquired
+
+Return Value:
+
+    None
+
+--*/
+{
+    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                           (PVOID)EX_PUSH_LOCK_EXCLUSIVE,
+                                           NULL) != NULL) {
+        ExfAcquirePushLockExclusive (PushLock);
+    }
+}
+
+static
+BOOLEAN
+ExTryAcquirePushLockExclusive (
+     IN PEX_PUSH_LOCK PushLock
+     )
+/*++
+
+Routine Description:
+
+    Try and acquire a push lock exclusively
+
+Arguments:
+
+    PushLock - Push lock to be acquired
+
+Return Value:
+
+    BOOLEAN - TRUE: Acquire was successfull, FALSE: Lock was already acquired
+
+--*/
+{
+    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                           (PVOID)EX_PUSH_LOCK_EXCLUSIVE,
+                                           NULL) == NULL) {
+        return TRUE;
+    } else {
+        return FALSE;
+    }
+}
+
+static
+VOID
+ExReleasePushLockExclusive (
+     IN PEX_PUSH_LOCK PushLock
+     )
+/*++
+
+Routine Description:
+
+    Release a push lock that was acquired exclusively
+
+Arguments:
+
+    PushLock - Push lock to be released
+
+Return Value:
+
+    None
+
+--*/
+{
+    ASSERT (PushLock->Value & (EX_PUSH_LOCK_WAITING|EX_PUSH_LOCK_EXCLUSIVE));
+
+    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                           NULL,
+                                           (PVOID)EX_PUSH_LOCK_EXCLUSIVE) != (PVOID)EX_PUSH_LOCK_EXCLUSIVE) {
+        ExfReleasePushLock (PushLock);
+    }
+}
+
 int __libcpp_mutex_lock(__libcpp_mutex_t* __m) {
-  AcquireSRWLockExclusive((PSRWLOCK)__m);
+  ExAcquirePushLockExclusive((PEX_PUSH_LOCK)__m);
   return 0;
 }
 
-bool __libcpp_mutex_trylock(__libcpp_mutex_t* __m) { return TryAcquireSRWLockExclusive((PSRWLOCK)__m) != 0; }
+bool __libcpp_mutex_trylock(__libcpp_mutex_t* __m) { return ExTryAcquirePushLockExclusive((PEX_PUSH_LOCK)__m) != 0; }
 
 int __libcpp_mutex_unlock(__libcpp_mutex_t* __m) {
-  ReleaseSRWLockExclusive((PSRWLOCK)__m);
+  ExReleasePushLockExclusive((PEX_PUSH_LOCK)__m);
   return 0;
 }
 
@@ -91,6 +506,626 @@ int __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
 }
 
 // Condition Variable
+#define pthread_cleanup_push(F, A)
+#define pthread_testcancel()
+
+#define CHECK_COND(c)  { \
+    if (!(c) || !*c || (*c == _LIBCPP_CONDVAR_INITIALIZER) \
+        || ( ((cond_t *)(*c))->valid != (unsigned int)LIFE_COND ) ) \
+        return EINVAL; }
+
+#define LIFE_COND 0xC0BAB1FD
+#define DEAD_COND 0xC0DEADBF
+
+#define STATIC_COND_INITIALIZER(x)		((__libcpp_condvar_t)(x) == ((__libcpp_condvar_t)_LIBCPP_CONDVAR_INITIALIZER))
+
+typedef struct cond_t cond_t;
+struct cond_t
+{
+    unsigned int valid;
+    int busy;
+    LONG waiters_count_; /* Number of waiting threads.  */
+    LONG waiters_count_unblock_; /* Number of waiting threads whitch can be unblocked.  */
+    LONG waiters_count_gone_; /* Number of waiters which are gone.  */
+    CRITICAL_SECTION waiters_count_lock_; /* Serialize access to <waiters_count_>.  */
+    CRITICAL_SECTION waiters_q_lock_; /* Serialize access to sema_q.  */
+    LONG value_q;
+    CRITICAL_SECTION waiters_b_lock_; /* Serialize access to sema_b.  */
+    LONG value_b;
+    HANDLE sema_q; /* Semaphore used to queue up threads waiting for the condition to
+                 become signaled.  */
+    HANDLE sema_b; /* Semaphore used to queue up threads waiting for the condition which
+                 became signaled.  */
+};
+
+#define __pthread_shallcancel() 0
+
+static int do_sema_b_wait (HANDLE sema, int nointerrupt, DWORD timeout,CRITICAL_SECTION *cs, LONG *val);
+static int do_sema_b_release(HANDLE sema, LONG count,CRITICAL_SECTION *cs, LONG *val);
+static void cleanup_wait(void *arg);
+
+typedef struct sCondWaitHelper {
+    cond_t *c;
+    __libcpp_mutex_t *external_mutex;
+    int *r;
+} sCondWaitHelper;
+
+static int do_sema_b_wait_intern (HANDLE sema, int nointerrupt, DWORD timeout);
+
+static int
+pthread_cond_init (__libcpp_condvar_t *c, const void *a)
+{
+  cond_t *_c;
+  int r = 0;
+
+  if (!c)
+    return EINVAL;
+#if 0
+  if (a && *a == PTHREAD_PROCESS_SHARED)
+    return ENOSYS;
+#endif
+
+  if ( !(_c = (cond_t *)HeapAlloc ( GetProcessHeap (), 0, sizeof(*_c))) ) {
+      return ENOMEM;
+  }
+  _c->valid  = DEAD_COND;
+  _c->busy = 0;
+  _c->waiters_count_ = 0;
+  _c->waiters_count_gone_ = 0;
+  _c->waiters_count_unblock_ = 0;
+
+  _c->sema_q = CreateSemaphore (NULL,       /* no security */
+      0,          /* initially 0 */
+      0x7fffffff, /* max count */
+      NULL);      /* unnamed  */
+  _c->sema_b =  CreateSemaphore (NULL,       /* no security */
+      0,          /* initially 0 */
+      0x7fffffff, /* max count */
+      NULL);
+  if (_c->sema_q == NULL || _c->sema_b == NULL) {
+      if (_c->sema_q != NULL)
+        CloseHandle (_c->sema_q);
+      if (_c->sema_b != NULL)
+        CloseHandle (_c->sema_b);
+      free (_c);
+      r = EAGAIN;
+  } else {
+      InitializeCriticalSection(&_c->waiters_count_lock_);
+      InitializeCriticalSection(&_c->waiters_b_lock_);
+      InitializeCriticalSection(&_c->waiters_q_lock_);
+      _c->value_q = 0;
+      _c->value_b = 1;
+  }
+  if (!r)
+    {
+      _c->valid = LIFE_COND;
+      *c = _c;
+    }
+  else
+    *c = NULL;
+  return r;
+}
+
+static __libcpp_mutex_t cond_locked = _LIBCPP_MUTEX_INITIALIZER;
+
+static int
+cond_static_init (__libcpp_condvar_t *c)
+{
+  int r = 0;
+
+  __libcpp_mutex_lock (&cond_locked);
+  if (c == NULL)
+    r = EINVAL;
+  else if (*c == _LIBCPP_CONDVAR_INITIALIZER)
+    r = pthread_cond_init (c, NULL);
+  else
+    /* We assume someone was faster ... */
+    r = 0;
+  __libcpp_mutex_unlock (&cond_locked);
+  return r;
+}
+
+int
+__libcpp_condvar_destroy (__libcpp_condvar_t *c)
+{
+  cond_t *_c;
+  int r;
+  if (!c)
+    return EINVAL;
+  if (*c == _LIBCPP_CONDVAR_INITIALIZER)
+    {
+      __libcpp_mutex_lock (&cond_locked);
+      if (*c == _LIBCPP_CONDVAR_INITIALIZER)
+      {
+        *c = NULL;
+        r = 0;
+      }
+      else
+        r = EBUSY;
+      __libcpp_mutex_unlock (&cond_locked);
+      return r;
+    }
+  _c = (cond_t *) *c;
+  r = do_sema_b_wait(_c->sema_b, 0, INFINITE,&_c->waiters_b_lock_,&_c->value_b);
+  if (r != 0)
+    return r;
+  if (!TryEnterCriticalSection (&_c->waiters_count_lock_))
+    {
+       do_sema_b_release (_c->sema_b, 1,&_c->waiters_b_lock_,&_c->value_b);
+       return EBUSY;
+    }
+  if (_c->waiters_count_ > _c->waiters_count_gone_)
+    {
+      r = do_sema_b_release (_c->sema_b, 1,&_c->waiters_b_lock_,&_c->value_b);
+      if (!r) r = EBUSY;
+      LeaveCriticalSection(&_c->waiters_count_lock_);
+      return r;
+    }
+  *c = NULL;
+  do_sema_b_release (_c->sema_b, 1,&_c->waiters_b_lock_,&_c->value_b);
+
+  if (!CloseHandle (_c->sema_q) && !r)
+    r = EINVAL;
+  if (!CloseHandle (_c->sema_b) && !r)
+    r = EINVAL;
+  LeaveCriticalSection (&_c->waiters_count_lock_);
+  DeleteCriticalSection(&_c->waiters_count_lock_);
+  DeleteCriticalSection(&_c->waiters_b_lock_);
+  DeleteCriticalSection(&_c->waiters_q_lock_);
+  _c->valid  = DEAD_COND;
+  HeapFree ( GetProcessHeap () , 0, _c);
+  return 0;
+}
+
+int
+__libcpp_condvar_signal (__libcpp_condvar_t *c)
+{
+  cond_t *_c;
+  int r;
+
+  if (!c)
+    return EINVAL;
+  _c = (cond_t *)*c;
+  if (_c == (cond_t *)_LIBCPP_CONDVAR_INITIALIZER)
+    return 0;
+  else if (_c->valid != (unsigned int)LIFE_COND)
+    return EINVAL;
+
+  EnterCriticalSection (&_c->waiters_count_lock_);
+  /* If there aren't any waiters, then this is a no-op.   */
+  if (_c->waiters_count_unblock_ != 0)
+    {
+      if (_c->waiters_count_ == 0)
+      {
+        LeaveCriticalSection (&_c->waiters_count_lock_);
+        /* pthread_testcancel(); */
+        return 0;
+      }
+      _c->waiters_count_ -= 1;
+      _c->waiters_count_unblock_ += 1;
+    }
+  else if (_c->waiters_count_ > _c->waiters_count_gone_)
+    {
+      r = do_sema_b_wait (_c->sema_b, 1, INFINITE,&_c->waiters_b_lock_,&_c->value_b);
+      if (r != 0)
+      {
+        LeaveCriticalSection (&_c->waiters_count_lock_);
+        /* pthread_testcancel(); */
+        return r;
+      }
+      if (_c->waiters_count_gone_ != 0)
+      {
+        _c->waiters_count_ -= _c->waiters_count_gone_;
+        _c->waiters_count_gone_ = 0;
+      }
+      _c->waiters_count_ -= 1;
+      _c->waiters_count_unblock_ = 1;
+    }
+  else
+    {
+      LeaveCriticalSection (&_c->waiters_count_lock_);
+      /* pthread_testcancel(); */
+      return 0;
+    }
+  LeaveCriticalSection (&_c->waiters_count_lock_);
+  r = do_sema_b_release(_c->sema_q, 1,&_c->waiters_q_lock_,&_c->value_q);
+  /* pthread_testcancel(); */
+  return r;
+}
+
+int
+__libcpp_condvar_broadcast (__libcpp_condvar_t *c)
+{
+  cond_t *_c;
+  int r;
+  int relCnt = 0;
+
+  if (!c)
+    return EINVAL;
+  _c = (cond_t *)*c;
+  if (_c == (cond_t*)_LIBCPP_CONDVAR_INITIALIZER)
+    return 0;
+  else if (_c->valid != (unsigned int)LIFE_COND)
+    return EINVAL;
+
+  EnterCriticalSection (&_c->waiters_count_lock_);
+  /* If there aren't any waiters, then this is a no-op.   */
+  if (_c->waiters_count_unblock_ != 0)
+    {
+      if (_c->waiters_count_ == 0)
+      {
+        LeaveCriticalSection (&_c->waiters_count_lock_);
+        /* pthread_testcancel(); */
+        return 0;
+      }
+      relCnt = _c->waiters_count_;
+      _c->waiters_count_ = 0;
+      _c->waiters_count_unblock_ += relCnt;
+    }
+  else if (_c->waiters_count_ > _c->waiters_count_gone_)
+    {
+      r = do_sema_b_wait (_c->sema_b, 1, INFINITE,&_c->waiters_b_lock_,&_c->value_b);
+      if (r != 0)
+      {
+        LeaveCriticalSection (&_c->waiters_count_lock_);
+        /* pthread_testcancel(); */
+        return r;
+      }
+      if (_c->waiters_count_gone_ != 0)
+      {
+        _c->waiters_count_ -= _c->waiters_count_gone_;
+        _c->waiters_count_gone_ = 0;
+      }
+      relCnt = _c->waiters_count_;
+      _c->waiters_count_ = 0;
+      _c->waiters_count_unblock_ = relCnt;
+    }
+  else
+    {
+      LeaveCriticalSection (&_c->waiters_count_lock_);
+      /* pthread_testcancel(); */
+      return 0;
+    }
+  LeaveCriticalSection (&_c->waiters_count_lock_);
+  r = do_sema_b_release(_c->sema_q, relCnt,&_c->waiters_q_lock_,&_c->value_q);
+  /* pthread_testcancel(); */
+  return r;
+}
+
+int
+__libcpp_condvar_wait (__libcpp_condvar_t *c, __libcpp_mutex_t *external_mutex)
+{
+  sCondWaitHelper ch;
+  cond_t *_c;
+  int r;
+
+  /* pthread_testcancel(); */
+
+  if (!c)
+    return EINVAL;
+  _c = (cond_t *)*c;
+  if (*c == _LIBCPP_CONDVAR_INITIALIZER)
+  {
+    r = cond_static_init(c);
+    if (r != 0 && r != EBUSY)
+      return r;
+    _c = (cond_t *) *c;
+  } else if (_c->valid != (unsigned int)LIFE_COND)
+    return EINVAL;
+
+  r = do_sema_b_wait (_c->sema_b, 0, INFINITE,&_c->waiters_b_lock_,&_c->value_b);
+  if (r != 0)
+    return r;
+  EnterCriticalSection (&_c->waiters_count_lock_);
+  _c->waiters_count_++;
+  LeaveCriticalSection(&_c->waiters_count_lock_);
+  r = do_sema_b_release (_c->sema_b, 1,&_c->waiters_b_lock_,&_c->value_b);
+  if (r != 0)
+    return r;
+
+  ch.c = _c;
+  ch.r = &r;
+  ch.external_mutex = external_mutex;
+
+  pthread_cleanup_push(cleanup_wait, (void *) &ch);
+  r = __libcpp_mutex_unlock(external_mutex);
+  if (!r)
+    r = do_sema_b_wait (_c->sema_q, 0, INFINITE,&_c->waiters_q_lock_,&_c->value_q);
+
+#if 0
+  pthread_cleanup_pop(1);
+#endif
+  cleanup_wait( (void *) &ch);
+  return r;
+}
+
+static int
+pthread_cond_timedwait_impl (__libcpp_condvar_t *c, __libcpp_mutex_t *external_mutex, timespec *t, int rel)
+{
+  sCondWaitHelper ch;
+  DWORD dwr;
+  int r;
+  cond_t *_c;
+
+  /* pthread_testcancel(); */
+
+  if (!c)
+    return EINVAL;
+  _c = (cond_t *)*c;
+  if (_c == (cond_t *)_LIBCPP_CONDVAR_INITIALIZER)
+  {
+    r = cond_static_init(c);
+    if (r && r != EBUSY)
+      return r;
+    _c = (cond_t *) *c;
+  } else if ((_c)->valid != (unsigned int)LIFE_COND)
+    return EINVAL;
+
+  using namespace std::chrono;
+
+  auto duration   = seconds(t->tv_sec) + nanoseconds(t->tv_nsec);
+  auto abstime    = system_clock::time_point(duration_cast<system_clock::duration>(duration));
+  auto timeout_ms = duration_cast<milliseconds>(abstime - system_clock::now());
+
+#if 0
+  if (rel == 0)
+  {
+    dwr = dwMilliSecs(_pthread_rel_time_in_ms(t));
+  }
+  else
+  {
+    dwr = dwMilliSecs(_pthread_time_in_ms_from_timespec(t));
+  }
+#endif
+    dwr = timeout_ms.count() > 0 ? timeout_ms.count()   : 0;
+
+  r = do_sema_b_wait (_c->sema_b, 0, INFINITE,&_c->waiters_b_lock_,&_c->value_b);
+  if (r != 0)
+    return r;
+  _c->waiters_count_++;
+  r = do_sema_b_release (_c->sema_b, 1,&_c->waiters_b_lock_,&_c->value_b);
+  if (r != 0)
+    return r;
+
+  ch.c = _c;
+  ch.r = &r;
+  ch.external_mutex = external_mutex;
+  {
+    pthread_cleanup_push(cleanup_wait, (void *) &ch);
+
+    r = __libcpp_mutex_unlock(external_mutex);
+    if (!r)
+      r = do_sema_b_wait (_c->sema_q, 0, dwr,&_c->waiters_q_lock_,&_c->value_q);
+
+#if 0
+    pthread_cleanup_pop(1);
+#endif
+    cleanup_wait( (void *) &ch);
+  }
+  return r;
+}
+
+int
+__libcpp_condvar_timedwait(__libcpp_condvar_t *c, __libcpp_mutex_t *m, timespec *t)
+{
+  return pthread_cond_timedwait_impl(c, m, t, 0);
+}
+
+static void
+cleanup_wait (void *arg)
+{
+  int n, r;
+  sCondWaitHelper *ch = (sCondWaitHelper *) arg;
+  cond_t *_c;
+
+  _c = ch->c;
+  EnterCriticalSection (&_c->waiters_count_lock_);
+  n = _c->waiters_count_unblock_;
+  if (n != 0)
+    _c->waiters_count_unblock_ -= 1;
+  else if ((INT_MAX/2) - 1 == _c->waiters_count_gone_)
+  {
+    _c->waiters_count_gone_ += 1;
+    r = do_sema_b_wait (_c->sema_b, 1, INFINITE,&_c->waiters_b_lock_,&_c->value_b);
+    if (r != 0)
+    {
+      LeaveCriticalSection(&_c->waiters_count_lock_);
+      ch->r[0] = r;
+      return;
+    }
+    _c->waiters_count_ -= _c->waiters_count_gone_;
+    r = do_sema_b_release (_c->sema_b, 1,&_c->waiters_b_lock_,&_c->value_b);
+    if (r != 0)
+    {
+      LeaveCriticalSection(&_c->waiters_count_lock_);
+      ch->r[0] = r;
+      return;
+    }
+    _c->waiters_count_gone_ = 0;
+  }
+  else
+    _c->waiters_count_gone_ += 1;
+  LeaveCriticalSection (&_c->waiters_count_lock_);
+
+  if (n == 1)
+  {
+    r = do_sema_b_release (_c->sema_b, 1,&_c->waiters_b_lock_,&_c->value_b);
+    if (r != 0)
+    {
+      ch->r[0] = r;
+      return;
+    }
+  }
+  r = __libcpp_mutex_lock(ch->external_mutex);
+  if (r != 0)
+    ch->r[0] = r;
+}
+
+static int
+do_sema_b_wait (HANDLE sema, int nointerrupt, DWORD timeout,CRITICAL_SECTION *cs, LONG *val)
+{
+  int r;
+  LONG v;
+  EnterCriticalSection(cs);
+  InterlockedDecrement(val);
+  v = val[0];
+  LeaveCriticalSection(cs);
+  if (v >= 0)
+    return 0;
+  r = do_sema_b_wait_intern (sema, nointerrupt, timeout);
+  EnterCriticalSection(cs);
+  if (r != 0)
+    InterlockedIncrement(val);
+  LeaveCriticalSection(cs);
+  return r;
+}
+
+static int
+do_sema_b_wait_intern (HANDLE sema, int nointerrupt, DWORD timeout)
+{
+  HANDLE arr[2];
+  DWORD maxH = 1;
+  int r = 0;
+  DWORD res, dt;
+  if (nointerrupt == 1)
+  {
+    res = WaitForSingleObject(sema, timeout);
+    switch (res) {
+    case WAIT_TIMEOUT:
+        r = ETIMEDOUT;
+        break;
+    case WAIT_ABANDONED:
+        r = EPERM;
+        break;
+    case WAIT_OBJECT_0:
+        break;
+    default:
+        /*We can only return EINVAL though it might not be posix compliant  */
+        r = EINVAL;
+    }
+    if (r != 0 && r != EINVAL && WaitForSingleObject(sema, 0) == WAIT_OBJECT_0)
+      r = 0;
+    return r;
+  }
+  arr[0] = sema;
+#if 0
+  arr[1] = (HANDLE) pthread_getevent ();
+#endif
+  arr[1] = (HANDLE) NULL;
+  if (arr[1] != NULL) maxH += 1;
+  if (maxH == 2)
+  {
+redo:
+      res = WaitForMultipleObjects(maxH, arr, 0, timeout);
+      switch (res) {
+      case WAIT_TIMEOUT:
+          r = ETIMEDOUT;
+          break;
+      case (WAIT_OBJECT_0 + 1):
+          ResetEvent(arr[1]);
+          if (nointerrupt != 2)
+            {
+            pthread_testcancel();
+            return EINVAL;
+            }
+          pthread_testcancel ();
+          goto redo;
+      case WAIT_ABANDONED:
+          r = EPERM;
+          break;
+      case WAIT_OBJECT_0:
+          r = 0;
+          break;
+      default:
+          /*We can only return EINVAL though it might not be posix compliant  */
+          r = EINVAL;
+      }
+      if (r != 0 && r != EINVAL && WaitForSingleObject(arr[0], 0) == WAIT_OBJECT_0)
+        r = 0;
+      if (r != 0 && nointerrupt != 2 && __pthread_shallcancel ())
+        return EINVAL;
+      return r;
+  }
+  if (timeout == INFINITE)
+  {
+    do {
+      res = WaitForSingleObject(sema, 40);
+      switch (res) {
+      case WAIT_TIMEOUT:
+          r = ETIMEDOUT;
+          break;
+      case WAIT_ABANDONED:
+          r = EPERM;
+          break;
+      case WAIT_OBJECT_0:
+          r = 0;
+          break;
+      default:
+          /*We can only return EINVAL though it might not be posix compliant  */
+          r = EINVAL;
+      }
+      if (r != 0 && __pthread_shallcancel ())
+      {
+        if (nointerrupt != 2)
+          pthread_testcancel();
+        return EINVAL;
+      }
+    } while (r == ETIMEDOUT);
+    if (r != 0 && r != EINVAL && WaitForSingleObject(sema, 0) == WAIT_OBJECT_0)
+      r = 0;
+    return r;
+  }
+  dt = 20;
+  do {
+    if (dt > timeout) dt = timeout;
+    res = WaitForSingleObject(sema, dt);
+    switch (res) {
+    case WAIT_TIMEOUT:
+        r = ETIMEDOUT;
+        break;
+    case WAIT_ABANDONED:
+        r = EPERM;
+        break;
+    case WAIT_OBJECT_0:
+        r = 0;
+        break;
+    default:
+        /*We can only return EINVAL though it might not be posix compliant  */
+        r = EINVAL;
+    }
+    timeout -= dt;
+    if (timeout != 0 && r != 0 && __pthread_shallcancel ())
+      return EINVAL;
+  } while (r == ETIMEDOUT && timeout != 0);
+  if (r != 0 && r == ETIMEDOUT && WaitForSingleObject(sema, 0) == WAIT_OBJECT_0)
+    r = 0;
+  if (r != 0 && nointerrupt != 2)
+    pthread_testcancel();
+  return r;
+}
+
+static int
+do_sema_b_release(HANDLE sema, LONG count,CRITICAL_SECTION *cs, LONG *val)
+{
+  int wc;
+  EnterCriticalSection(cs);
+  if (((long long) val[0] + (long long) count) > (long long) 0x7fffffffLL)
+  {
+    LeaveCriticalSection(cs);
+    return ERANGE;
+  }
+  wc = -val[0];
+  InterlockedExchangeAdd(val, count);
+  if (wc <= 0 || ReleaseSemaphore(sema, (wc < count ? wc : count), NULL))
+  {
+    LeaveCriticalSection(cs);
+    return 0;
+  }
+  InterlockedExchangeAdd(val, -count);
+  LeaveCriticalSection(cs);
+  return EINVAL;
+}
+#if 0
 int __libcpp_condvar_signal(__libcpp_condvar_t* __cv) {
   WakeConditionVariable((PCONDITION_VARIABLE)__cv);
   return 0;
@@ -135,6 +1171,7 @@ int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
   static_cast<void>(__cv);
   return 0;
 }
+#endif
 
 // Execute Once
 static inline _LIBCPP_HIDE_FROM_ABI BOOL CALLBACK
@@ -150,10 +1187,31 @@ __libcpp_init_once_execute_once_thunk(PINIT_ONCE __init_once, PVOID __parameter,
   return TRUE;
 }
 
+static int fake_pthread_once(volatile long *once_control,
+                             void (*init_routine)(void)) {
+    // Try for a fast path first. Note: this should be an acquire semantics read
+    // It is on x86 and x64, where Windows runs.
+    if (*once_control != 1) {
+        while (1) {
+            switch (InterlockedCompareExchange(once_control, 2, 0)) {
+                case 0:
+                    init_routine();
+                    InterlockedExchange(once_control, 1);
+                    return 0;
+                case 1:
+                    // The initializer has already been executed
+                    return 0;
+                default:
+                    // The initializer is being processed by another thread
+                    SwitchToThread();
+            }
+        }
+    }
+    return 0;
+}
+
 int __libcpp_execute_once(__libcpp_exec_once_flag* __flag, void (*__init_routine)(void)) {
-  if (!InitOnceExecuteOnce(
-          (PINIT_ONCE)__flag, __libcpp_init_once_execute_once_thunk, reinterpret_cast<void*>(__init_routine), nullptr))
-    return GetLastError();
+  fake_pthread_once((volatile long *)__flag, __init_routine);
   return 0;
 }
 
@@ -216,7 +1274,54 @@ __libcpp_thread_id __libcpp_thread_get_current_id()
 
 __libcpp_thread_id __libcpp_thread_get_current_id() { return GetCurrentThreadId(); }
 
-__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t* __t) { return GetThreadId(*__t); }
+#define NTSTATUS ULONG
+
+// The thread environment block internal type.
+struct TEB {
+  NT_TIB Tib;
+  // Rest of struct is ignored.
+};
+
+__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t)
+{
+  // Define the internal types we need to invoke NtQueryInformationThread.
+  enum THREAD_INFORMATION_CLASS { ThreadBasicInformation };
+
+  struct CLIENT_ID {
+    HANDLE UniqueProcess;
+    HANDLE UniqueThread;
+  };
+
+  struct THREAD_BASIC_INFORMATION {
+    NTSTATUS ExitStatus;
+    TEB* Teb;
+    CLIENT_ID ClientId;
+    KAFFINITY AffinityMask;
+    LONG Priority;
+    LONG BasePriority;
+  };
+
+  using NtQueryInformationThreadFunction =
+      NTSTATUS (WINAPI*)(HANDLE, THREAD_INFORMATION_CLASS, PVOID, ULONG,
+                         PULONG);
+
+  const NtQueryInformationThreadFunction nt_query_information_thread =
+      reinterpret_cast<NtQueryInformationThreadFunction>(
+          ::GetProcAddress(::GetModuleHandle(L"ntdll.dll"),
+                           "NtQueryInformationThread"));
+  if (!nt_query_information_thread)
+    return 0;
+
+  THREAD_BASIC_INFORMATION basic_info = {0};
+  NTSTATUS status =
+      nt_query_information_thread(*__t, ThreadBasicInformation,
+                                  &basic_info, sizeof(THREAD_BASIC_INFORMATION),
+                                  nullptr);
+  if (status != 0)
+    return 0;
+
+  return (ULONG)(ULONG_PTR) (basic_info.ClientId.UniqueThread);
+}
 
 int __libcpp_thread_join(__libcpp_thread_t* __t) {
   if (WaitForSingleObjectEx(*__t, INFINITE, FALSE) == WAIT_FAILED)
@@ -1287,8 +1287,19 @@ void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns)
 }
 
 // Thread Local Storage
+typedef DWORD(WINAPI* PFNFLSALLOC)(PFLS_CALLBACK_FUNCTION);
+typedef PVOID(WINAPI* PFNFLSGETVALUE)(DWORD);
+typedef BOOL(WINAPI* PFNFLSSETVALUE)(DWORD, PVOID);
 int __libcpp_tls_create(__libcpp_tls_key* __key, void(_LIBCPP_TLS_DESTRUCTOR_CC* __at_exit)(void*)) {
-  DWORD index = FlsAlloc(__at_exit);
+  DWORD index;
+	if (PFNFLSALLOC const fls_alloc = (PFNFLSALLOC)GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "FlsAlloc"))
+	{
+		index = fls_alloc(__at_exit);
+	}
+	else
+	{
+		index = TlsAlloc();
+	}
   if (index == FLS_OUT_OF_INDEXES)
     return GetLastError();
   *__key = index;
@@ -1299,10 +1310,25 @@ int __libcpp_tls_create(__libcpp_tls_key* __key,
   return 0;
 }
 
-void* __libcpp_tls_get(__libcpp_tls_key __key) { return FlsGetValue(__key); }
+void *__libcpp_tls_get(__libcpp_tls_key __key)
+{
+        if (PFNFLSGETVALUE const fls_get_value = (PFNFLSGETVALUE)GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "FlsGetValue"))
+        {
+            return fls_get_value(__key);
+        }
+
+        return TlsGetValue(__key);
+}
 
 int __libcpp_tls_set(__libcpp_tls_key __key, void* __p) {
-  if (!FlsSetValue(__key, __p))
+        if (PFNFLSSETVALUE const fls_set_value = (PFNFLSSETVALUE)GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "FlsSetValue"))
+        {
+  if (!fls_set_value(__key, __p))
+    return GetLastError();
+  return 0;
+        }
+
+  if (!TlsSetValue(__key, __p))
     return GetLastError();
   return 0;
 }
