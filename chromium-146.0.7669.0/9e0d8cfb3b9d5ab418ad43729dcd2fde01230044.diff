diff --git a/content/browser/gpu/gpu_process_host.cc b/content/browser/gpu/gpu_process_host.cc
index 7804830e0e3b0..b3beaa1859443 100644
--- a/content/browser/gpu/gpu_process_host.cc
+++ b/content/browser/gpu/gpu_process_host.cc
@@ -415,25 +419,38 @@ class GpuSandboxedProcessLauncherDelegate
   bool InitializeConfig(sandbox::TargetConfig* config) override {
     DCHECK(!config->IsConfigured());
 
-    sandbox::ResultCode result = config->SetTokenLevel(
-        sandbox::USER_RESTRICTED_SAME_ACCESS, sandbox::USER_LIMITED);
-    if (result != sandbox::SBOX_ALL_OK) {
-      return false;
-    }
+    if (UseOpenGLRenderer()) {
+      // Open GL path.
+      sandbox::ResultCode result = config->SetTokenLevel(
+          sandbox::USER_RESTRICTED_SAME_ACCESS, sandbox::USER_LIMITED);
+      if (result != sandbox::SBOX_ALL_OK)
+        return false;
 
-    // UI restrictions break when we access Windows from outside our job.
-    // However, we don't want a proxy window in this process because it can
-    // introduce deadlocks where the renderer blocks on the gpu, which in
-    // turn blocks on the browser UI thread. So, instead we forgo a window
-    // message pump entirely and just add job restrictions to prevent child
-    // processes.
-    result = sandbox::policy::SandboxWin::SetJobLevel(
-        sandbox::mojom::Sandbox::kGpu, sandbox::JobLevel::kLimitedUser,
-        JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS | JOB_OBJECT_UILIMIT_DESKTOP |
-            JOB_OBJECT_UILIMIT_EXITWINDOWS | JOB_OBJECT_UILIMIT_DISPLAYSETTINGS,
-        config);
-    if (result != sandbox::SBOX_ALL_OK) {
-      return false;
+      result = sandbox::policy::SandboxWin::SetJobLevel(
+          sandbox::mojom::Sandbox::kGpu, sandbox::JobLevel::kUnprotected, 0,
+          config);
+      if (result != sandbox::SBOX_ALL_OK)
+        return false;
+    } else {
+      sandbox::ResultCode result = config->SetTokenLevel(
+          sandbox::USER_RESTRICTED_SAME_ACCESS, sandbox::USER_LIMITED);
+      if (result != sandbox::SBOX_ALL_OK)
+        return false;
+
+      // UI restrictions break when we access Windows from outside our job.
+      // However, we don't want a proxy window in this process because it can
+      // introduce deadlocks where the renderer blocks on the gpu, which in
+      // turn blocks on the browser UI thread. So, instead we forgo a window
+      // message pump entirely and just add job restrictions to prevent child
+      // processes.
+      result = sandbox::policy::SandboxWin::SetJobLevel(
+          sandbox::mojom::Sandbox::kGpu, sandbox::JobLevel::kLimitedUser,
+          JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS | JOB_OBJECT_UILIMIT_DESKTOP |
+              JOB_OBJECT_UILIMIT_EXITWINDOWS |
+              JOB_OBJECT_UILIMIT_DISPLAYSETTINGS,
+          config);
+      if (result != sandbox::SBOX_ALL_OK)
+        return false;
     }
 
     // Check if we are running on the winlogon desktop and set a delayed
@@ -446,7 +463,8 @@ class GpuSandboxedProcessLauncherDelegate
     if (ShouldSetDelayedIntegrity()) {
       config->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
     } else {
-      result = config->SetIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
+      sandbox::ResultCode result =
+          config->SetIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
       if (result != sandbox::SBOX_ALL_OK)
         return false;
     }
@@ -491,6 +509,11 @@ class GpuSandboxedProcessLauncherDelegate
       kMaxValue = kDesktopAccessMediumIl,
   };
 
+  bool UseOpenGLRenderer() {
+    // TODO(crbug.com/40848940): Remove this function.
+    return false;
+  }
+
   bool CanLowIntegrityAccessDesktop() {
     // Access required for UI thread to initialize (when user32.dll loads
     // without win32k lockdown).
@@ -524,6 +547,10 @@ class GpuSandboxedProcessLauncherDelegate
   }
 
   bool ShouldSetDelayedIntegrity() {
+    if (UseOpenGLRenderer()) {
+      return true;
+    }
+
     // Desktop access is needed to load user32.dll, we can lower token in child
     // process after that's done.
     if (CanLowIntegrityAccessDesktop()) {
