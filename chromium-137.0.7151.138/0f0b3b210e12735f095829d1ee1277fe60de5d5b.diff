diff --git a/base/threading/platform_thread_win.cc b/base/threading/platform_thread_win.cc
index 6631ba69da171..19372539f4ac5 100644
--- a/base/threading/platform_thread_win.cc
+++ b/base/threading/platform_thread_win.cc
@@ -223,12 +223,83 @@ bool PlatformThread::CreateNonJoinableWithPriority(size_t stack_size,
                               thread_type, pump_type_hint);
 }
 
+#define NTSTATUS ULONG
+
+// The thread environment block internal type.
+struct TEB {
+  NT_TIB Tib;
+  // Rest of struct is ignored.
+};
+
+DWORD
+APIENTRY
+GetThreadId(
+    HANDLE thread_handle
+    )
+/*++
+
+Routine Description:
+
+    Gets the thread ID of the thread open via the specified handle
+
+Arguments:
+
+    Thread - Handle of thread to do the query on
+
+Return Value:
+
+    Returns a unique value representing the thread ID of the
+    executing thread.  The return value may be used to identify a thread
+    in the system. If the function fails the return value is zero.
+
+--*/
+
+{
+  // Define the internal types we need to invoke NtQueryInformationThread.
+  enum THREAD_INFORMATION_CLASS { ThreadBasicInformation };
+
+  struct CLIENT_ID {
+    HANDLE UniqueProcess;
+    HANDLE UniqueThread;
+  };
+
+  struct THREAD_BASIC_INFORMATION {
+    NTSTATUS ExitStatus;
+    raw_ptr<TEB> Teb;
+    CLIENT_ID ClientId;
+    KAFFINITY AffinityMask;
+    LONG Priority;
+    LONG BasePriority;
+  };
+
+  using NtQueryInformationThreadFunction =
+      NTSTATUS (WINAPI*)(HANDLE, THREAD_INFORMATION_CLASS, PVOID, ULONG,
+                         PULONG);
+
+  const NtQueryInformationThreadFunction nt_query_information_thread =
+      reinterpret_cast<NtQueryInformationThreadFunction>(
+          ::GetProcAddress(::GetModuleHandle(L"ntdll.dll"),
+                           "NtQueryInformationThread"));
+  if (!nt_query_information_thread)
+    return 0;
+
+  THREAD_BASIC_INFORMATION basic_info = {0};
+  NTSTATUS status =
+      nt_query_information_thread(thread_handle, ThreadBasicInformation,
+                                  &basic_info, sizeof(THREAD_BASIC_INFORMATION),
+                                  nullptr);
+  if (status != 0)
+    return 0;
+
+  return (ULONG)(ULONG_PTR) (basic_info.ClientId.UniqueThread);
+}
+
 // static
 void PlatformThread::Join(PlatformThreadHandle thread_handle) {
   DCHECK(thread_handle.platform_handle());
 
   DWORD thread_id = 0;
-  thread_id = ::GetThreadId(thread_handle.platform_handle());
+  thread_id = GetThreadId(thread_handle.platform_handle());
   DWORD last_error = 0;
   if (!thread_id) {
     last_error = ::GetLastError();
