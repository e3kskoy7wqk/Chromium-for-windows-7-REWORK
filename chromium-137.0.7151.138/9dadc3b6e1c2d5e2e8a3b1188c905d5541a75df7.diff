diff --git a/third_party/boringssl/src/crypto/internal.h b/third_party/boringssl/src/crypto/internal.h
index 438d71693..61f610027 100644
--- a/third_party/boringssl/src/crypto/internal.h
+++ b/third_party/boringssl/src/crypto/internal.h
@@ -298,8 +298,8 @@ static inline int constant_time_select_int(unsigned int mask, int a, int b) {
 typedef uint32_t CRYPTO_once_t;
 #define CRYPTO_ONCE_INIT 0
 #elif defined(OPENSSL_WINDOWS_THREADS)
-typedef INIT_ONCE CRYPTO_once_t;
-#define CRYPTO_ONCE_INIT INIT_ONCE_STATIC_INIT
+typedef volatile LONG CRYPTO_once_t;
+#define CRYPTO_ONCE_INIT 0
 #elif defined(OPENSSL_PTHREADS)
 typedef pthread_once_t CRYPTO_once_t;
 #define CRYPTO_ONCE_INIT PTHREAD_ONCE_INIT
diff --git a/third_party/boringssl/src/crypto/thread_win.cc b/third_party/boringssl/src/crypto/thread_win.cc
index 263256560..8e231eb40 100644
--- a/third_party/boringssl/src/crypto/thread_win.cc
+++ b/third_party/boringssl/src/crypto/thread_win.cc
@@ -30,18 +31,63 @@
 #include <stdlib.h>
 #include <string.h>
 
-static BOOL CALLBACK call_once_init(INIT_ONCE *once, void *arg, void **out) {
-  void (**init)(void) = (void (**)(void))arg;
-  (**init)();
-  return TRUE;
-}
+union run_once_arg_t {
+  void (*func)(void);
+  void *data;
+};
+
+static void run_once(CRYPTO_once_t *once, void (*init)(union run_once_arg_t),
+                     union run_once_arg_t arg) {
+  /* Values must be aligned. */
+  assert((((uintptr_t) once) & 3) == 0);
+
+  /* This assumes that reading *once has acquire semantics. This should be true
+   * on x86 and x86-64, where we expect Windows to run. */
+#if !defined(OPENSSL_X86) && !defined(OPENSSL_X86_64)
+#error "Windows once code may not work on other platforms." \
+       "You can use InitOnceBeginInitialize on >=Vista"
+#endif
+  if (*once == 1) {
+    return;
+  }
 
-void CRYPTO_once(CRYPTO_once_t *once, void (*init)(void)) {
-  if (!InitOnceExecuteOnce(once, call_once_init, &init, NULL)) {
-    abort();
+  for (;;) {
+    switch (InterlockedCompareExchange(once, 2, 0)) {
+      case 0:
+        /* The value was zero so we are the first thread to call |CRYPTO_once|
+         * on it. */
+        init(arg);
+        /* Write one to indicate that initialisation is complete. */
+        InterlockedExchange(once, 1);
+        return;
+
+      case 1:
+        /* Another thread completed initialisation between our fast-path check
+         * and |InterlockedCompareExchange|. */
+        return;
+
+      case 2:
+        /* Another thread is running the initialisation. Switch to it then try
+         * again. */
+        SwitchToThread();
+        break;
+
+      default:
+        abort();
+    }
   }
 }
 
+static void call_once_init(union run_once_arg_t arg) {
+  arg.func();
+}
+
+void CRYPTO_once(CRYPTO_once_t *in_once, void (*init)(void)) {
+  union run_once_arg_t arg;
+  arg.func = init;
+  run_once(in_once, call_once_init, arg);
+}
+
 #define ASSERT(x)
 #define ASSERT_VALID(x)
 
