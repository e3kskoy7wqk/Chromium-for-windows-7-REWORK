diff --git a/base/task/thread_pool/thread_group.cc b/base/task/thread_pool/thread_group.cc
index 5d9a5e0773a55..56d8747540f91 100644
--- a/base/task/thread_pool/thread_group.cc
+++ b/base/task/thread_pool/thread_group.cc
@@ -17,7 +17,9 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/com_init_check_hook.h"
+#include "base/win/scoped_com_initializer.h"
 #include "base/win/scoped_winrt_initializer.h"
+#include "base/win/windows_version.h"
 #endif
 
 namespace base::internal {
@@ -325,8 +327,18 @@ bool ThreadGroup::ShouldYield(TaskSourceSortKey sort_key) {
 std::unique_ptr<win::ScopedWindowsThreadEnvironment>
 ThreadGroup::GetScopedWindowsThreadEnvironment(WorkerEnvironment environment) {
   std::unique_ptr<win::ScopedWindowsThreadEnvironment> scoped_environment;
-  if (environment == WorkerEnvironment::COM_MTA) {
-    scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+  switch (environment) {
+    case WorkerEnvironment::COM_MTA: {
+      if (win::GetVersion() >= win::Version::WIN8) {
+        scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+      } else {
+        scoped_environment = std::make_unique<win::ScopedCOMInitializer>(
+            win::ScopedCOMInitializer::kMTA);
+      }
+      break;
+    }
+    default:
+      break;
   }
   // Continuing execution with an uninitialized apartment may lead to broken
   // program invariants later on.
diff --git a/base/threading/platform_thread_win.cc b/base/threading/platform_thread_win.cc
index 030dc3448026c..316ba678a6d07 100644
--- a/base/threading/platform_thread_win.cc
+++ b/base/threading/platform_thread_win.cc
@@ -49,6 +47,14 @@ namespace {
 
 namespace {
 
+// The most common value returned by ::GetThreadPriority() after background
+// thread mode is enabled on Windows 7.
+constexpr int kWin7BackgroundThreadModePriority = 4;
+
+// Value sometimes returned by ::GetThreadPriority() after thread priority is
+// set to normal on Windows 7.
+constexpr int kWin7NormalPriority = 3;
+
 // These values are sometimes returned by ::GetThreadPriority().
 constexpr int kWinDisplayPriority1 = 5;
 constexpr int kWinDisplayPriority2 = 6;
@@ -231,7 +237,10 @@ void AssertMemoryPriority(HANDLE thread, int memory_priority) {
       reinterpret_cast<decltype(&::GetThreadInformation)>(::GetProcAddress(
           ::GetModuleHandle(L"Kernel32.dll"), "GetThreadInformation"));
 
-  DCHECK(get_thread_information_fn);
+  if (!get_thread_information_fn) {
+    DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+    return;
+  }
 
   MEMORY_PRIORITY_INFORMATION memory_priority_information = {};
   DCHECK(get_thread_information_fn(thread, ::ThreadMemoryPriority,
@@ -533,8 +542,14 @@ ThreadPriorityForTest PlatformThread::GetCurrentThreadPriorityForTest() {
   }
 
   switch (priority) {
+    case kWin7BackgroundThreadModePriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      return ThreadPriorityForTest::kBackground;
     case THREAD_PRIORITY_BELOW_NORMAL:
       return ThreadPriorityForTest::kUtility;
+    case kWin7NormalPriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      [[fallthrough]];
     case THREAD_PRIORITY_NORMAL:
       return ThreadPriorityForTest::kNormal;
     case kWinDisplayPriority1:
diff --git a/base/threading/platform_thread_win_unittest.cc b/base/threading/platform_thread_win_unittest.cc
index 3fc3a9efcedd7..43d99815630d1 100644
--- a/base/threading/platform_thread_win_unittest.cc
+++ b/base/threading/platform_thread_win_unittest.cc
@@ -17,8 +17,9 @@ namespace base {
 
 // It has been observed that calling
 // :SetThreadPriority(THREAD_MODE_BACKGROUND_BEGIN) in an IDLE_PRIORITY_CLASS
-// process never affects the return value of ::GetThreadPriority() or
-// the base priority reported in Process Explorer. It does however
+// process doesn't always affect the return value of ::GetThreadPriority() or
+// the base priority reported in Process Explorer (on Win7, the values are
+// sometimes affected while on Win8+ they are never affected). It does however
 // set the memory and I/O priorities to very low. This test confirms that
 // behavior which we suspect is a Windows kernel bug. If this test starts
 // failing, the mitigation for https://crbug.com/901483 in
@@ -49,15 +50,24 @@ TEST(PlatformThreadWinTest, SetBackgroundThreadModeFailsInIdlePriorityProcess) {
   // Begin thread mode background.
   EXPECT_TRUE(::SetThreadPriority(thread_handle, THREAD_MODE_BACKGROUND_BEGIN));
 
-  // On Win10+, GetThreadPriority() stays NORMAL and memory priority becomes
-  // VERY_LOW.
+  // On Win8, GetThreadPriority() stays NORMAL. On Win7, it can stay NORMAL or
+  // switch to one of the various priorities that are observed after entering
+  // thread mode background in a NORMAL_PRIORITY_CLASS process. On all Windows
+  // versions, memory priority becomes VERY_LOW.
   //
   // Note: this documents the aforementioned kernel bug. Ideally this would
   // *not* be the case.
   const int priority_after_thread_mode_background_begin =
       ::GetThreadPriority(thread_handle);
-  EXPECT_EQ(priority_after_thread_mode_background_begin,
-            THREAD_PRIORITY_NORMAL);
+  if (win::GetVersion() == win::Version::WIN7) {
+    const ThreadPriorityForTest priority =
+        PlatformThread::GetCurrentThreadPriorityForTest();
+    EXPECT_TRUE(priority == ThreadPriorityForTest::kNormal ||
+                priority == ThreadPriorityForTest::kBackground);
+  } else {
+    EXPECT_EQ(priority_after_thread_mode_background_begin,
+              THREAD_PRIORITY_NORMAL);
+  }
   internal::AssertMemoryPriority(thread_handle, MEMORY_PRIORITY_VERY_LOW);
 
   PlatformThread::Sleep(base::Seconds(1));
