diff --git a/base/memory/platform_shared_memory_region_win.cc b/base/memory/platform_shared_memory_region_win.cc
index e387015249731..bdf62a3e0c9c9 100644
--- a/base/memory/platform_shared_memory_region_win.cc
+++ b/base/memory/platform_shared_memory_region_win.cc
@@ -14,11 +14,16 @@
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/process/process_handle.h"
+#include "base/rand_util.h"
 #include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
 #include "base/types/expected.h"
 #include "partition_alloc/page_allocator.h"
 
-namespace base::subtle {
+namespace base {
+namespace subtle {
 
 namespace {
 
@@ -211,6 +216,18 @@ PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Create(Mode mode,
   }
 
   std::u16string name;
+  if (win::GetVersion() < win::Version::WIN8_1) {
+    // Windows < 8.1 ignores DACLs on certain unnamed objects (like shared
+    // sections). So, we generate a random name when we need to enforce
+    // read-only.
+    uint64_t rand_values[4];
+    RandBytes(base::byte_span_from_ref(rand_values));
+    name = ASCIIToUTF16(StringPrintf("CrSharedMem_%016llx%016llx%016llx%016llx",
+                                     rand_values[0], rand_values[1],
+                                     rand_values[2], rand_values[3]));
+    DCHECK(!name.empty());
+  }
+
   SECURITY_ATTRIBUTES sa = {sizeof(sa), &sd, FALSE};
   // Ask for the file mapping with reduced permisions to avoid passing the
   // access control permissions granted by default into unpriviledged process.
@@ -267,4 +284,5 @@ PlatformSharedMemoryRegion::PlatformSharedMemoryRegion(
     const UnguessableToken& guid)
     : handle_(std::move(handle)), mode_(mode), size_(size), guid_(guid) {}
 
-}  // namespace base::subtle
+}  // namespace subtle
+}  // namespace base
diff --git a/base/win/win_util.cc b/base/win/win_util.cc
index 13d8a980ea11b..b1b2f55484d7f 100644
--- a/base/win/win_util.cc
+++ b/base/win/win_util.cc
@@ -101,9 +101,11 @@ POWER_PLATFORM_ROLE GetPlatformRole() {
   return PowerDeterminePlatformRoleEx(POWER_PLATFORM_ROLE_V2);
 }
 
-// Because we used to support versions earlier than 8.1, we dynamically load
-// this function from user32.dll, so it won't fail to load in runtime.
-// TODO(https://crbug.com/1408307): Call SetProcessDpiAwareness directly.
+// Method used for Windows 8.1 and later.
+// Since we support versions earlier than 8.1, we must dynamically load this
+// function from user32.dll, so it won't fail to load in runtime. For earlier
+// Windows versions GetProcAddress will return null and report failure so that
+// callers can fall back on the deprecated SetProcessDPIAware.
 bool SetProcessDpiAwarenessWrapper(PROCESS_DPI_AWARENESS value) {
   if (!IsUser32AndGdi32Available())
     return false;
@@ -124,8 +126,9 @@ bool SetProcessDpiAwarenessWrapper(PROCESS_DPI_AWARENESS value) {
     return false;
   }
 
-  NOTREACHED() << "SetProcessDpiAwarenessInternal "
-                  "should be available on all platforms >= Windows 8.1";
+  DCHECK_LT(GetVersion(), Version::WIN8_1) << "SetProcessDpiAwarenessInternal "
+                                              "should be available on all "
+                                              "platforms >= Windows 8.1";
   return false;
 }
 
@@ -299,6 +302,12 @@ bool IsWindows10OrGreaterTabletMode(HWND hwnd) {
 void IsDeviceSlateWithKeyboard(HWND hwnd,
                                OnceCallback<void(bool, std::string)> callback) {
   std::ostringstream reason;
+  if (GetVersion() < Version::WIN8) {
+    reason << "Detection not supported";
+    return;
+  }
+
+  // This function is only supported for Windows 8 and up.
   if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kDisableUsbKeyboardDetect)) {
     reason << "Detection disabled";
@@ -561,6 +577,12 @@ bool IsDeviceUsedAsATablet(std::string* reason) {
   // reason is NULL.
   std::optional<bool> ret;
 
+  if (GetVersion() < Version::WIN8) {
+    if (reason)
+      *reason = "Tablet device detection not supported below Windows 8\n";
+    return false;
+  }
+
   if (GetSystemMetrics(SM_MAXIMUMTOUCHES) == 0) {
     if (!reason) {
       return false;
@@ -640,6 +662,10 @@ bool IsUser32AndGdi32Available() {
   static const bool is_user32_and_gdi32_available = [] {
     // If win32k syscalls aren't disabled, then user32 and gdi32 are available.
 
+    // Can't disable win32k prior to windows 8.
+    if (GetVersion() < Version::WIN8)
+      return true;
+
     using GetProcessMitigationPolicyType =
         decltype(GetProcessMitigationPolicy)*;
     GetProcessMitigationPolicyType get_process_mitigation_policy_func =
@@ -748,11 +774,15 @@ void EnableHighDPISupport() {
     return;
   }
 
-  // Fall back to per-monitor DPI for older versions of Win10.
-  PROCESS_DPI_AWARENESS process_dpi_awareness = PROCESS_PER_MONITOR_DPI_AWARE;
+  // Fall back to per-monitor DPI for older versions of Win10 instead of
+  // Win8.1 since Win8.1 does not have EnableChildWindowDpiMessage,
+  // necessary for correct non-client area scaling across monitors.
+  PROCESS_DPI_AWARENESS process_dpi_awareness =
+      GetVersion() >= Version::WIN10 ? PROCESS_PER_MONITOR_DPI_AWARE
+                                     : PROCESS_SYSTEM_DPI_AWARE;
   if (!SetProcessDpiAwarenessWrapper(process_dpi_awareness)) {
-    // For windows versions where SetProcessDpiAwareness fails, try its
-    // predecessor.
+    // For windows versions where SetProcessDpiAwareness is not available or
+    // failed, try its predecessor.
     BOOL result = ::SetProcessDPIAware();
     DCHECK(result) << "SetProcessDPIAware failed.";
   }
@@ -887,12 +887,23 @@ std::wstring GetWindowObjectName(HANDLE handle) {
 }
 
 bool GetPointerDevice(HANDLE device, POINTER_DEVICE_INFO& result) {
+  static const auto get_pointer_devices =
+      reinterpret_cast<decltype(&::GetPointerDevices)>(
+          base::win::GetUser32FunctionPointer("GetPointerDevices"));
+  if (!get_pointer_devices) {
+    return false;
+  }
+
   return ::GetPointerDevice(device, &result);
 }
 
 std::optional<std::vector<POINTER_DEVICE_INFO>> GetPointerDevices() {
+  static const auto get_pointer_devices =
+      reinterpret_cast<decltype(&::GetPointerDevices)>(
+          base::win::GetUser32FunctionPointer("GetPointerDevices"));
   uint32_t device_count;
-  if (!::GetPointerDevices(&device_count, nullptr)) {
+  if (!get_pointer_devices ||
+      !get_pointer_devices(&device_count, nullptr)) {
     return std::nullopt;
   }
 
@@ -905,6 +917,9 @@ std::optional<std::vector<POINTER_DEVICE_INFO>> GetPointerDevices() {
 
 bool RegisterPointerDeviceNotifications(HWND hwnd,
                                         bool notify_proximity_changes) {
+  if (!base::win::GetUser32FunctionPointer("RegisterPointerDeviceNotifications")) {
+    return true;
+  }
   return ::RegisterPointerDeviceNotifications(hwnd, notify_proximity_changes);
 }
 
