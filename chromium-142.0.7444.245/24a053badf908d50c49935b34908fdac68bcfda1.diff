diff --git a/ui/shell_dialogs/execute_select_file_win.cc b/ui/shell_dialogs/execute_select_file_win.cc
index 9f2e7d9a63c8f..39003adca261a 100644
--- a/ui/shell_dialogs/execute_select_file_win.cc
+++ b/ui/shell_dialogs/execute_select_file_win.cc
@@ -18,6 +18,320 @@
 #include "ui/shell_dialogs/select_file_utils_win.h"
 #include "ui/strings/grit/ui_strings.h"
 
+// Copyright (c) 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Copyright (c) 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_WIN_OPEN_FILE_NAME_WIN_H_
+#define UI_BASE_WIN_OPEN_FILE_NAME_WIN_H_
+
+#include <Windows.h>
+#include <Commdlg.h>
+
+#include <tuple>
+#include <vector>
+
+namespace base {
+class FilePath;
+}  // namespace base
+
+namespace ui {
+namespace win {
+
+// Encapsulates an OPENFILENAME struct and related buffers. Also provides static
+// methods for interpreting the properties of an OPENFILENAME.
+class OpenFileName {
+ public:
+  // Initializes the OPENFILENAME, which may be accessed using Get(). All fields
+  // will be NULL except for |lStructSize|, |lpstrFile|, and |nMaxFile|. The
+  // file buffer will initially contain a null-terminated empty string.
+  OpenFileName(HWND parent_window, DWORD flags);
+
+  OpenFileName(const OpenFileName&) = delete;
+  OpenFileName& operator=(const OpenFileName&) = delete;
+
+  ~OpenFileName();
+
+  // Initializes |lpstrFilter| from the label/pattern pairs in |filters|.
+  void SetFilters(
+      const std::vector<FileFilterSpec>& filters);
+
+  // Sets |lpstrInitialDir| and |lpstrFile|.
+  void SetInitialSelection(const base::FilePath& initial_directory,
+                           const base::FilePath& initial_filename);
+
+  // The save as dialog on Windows XP remembers its last position, and if the
+  // screen resolution has changed it may be off screen. This method will check
+  // if we are running on XP and if so install a hook to reposition the dialog
+  // if necessary.
+  void MaybeInstallWindowPositionHookForSaveAsOnXP();
+
+  // Returns the single selected file, or an empty path if there are more or
+  // less than one results.
+  base::FilePath GetSingleResult();
+
+  // Returns the selected file or files.
+  void GetResult(base::FilePath* directory,
+                 std::vector<base::FilePath>* filenames);
+
+  // Returns the OPENFILENAME structure.
+  OPENFILENAME* GetOPENFILENAME() { return &openfilename_; }
+
+  // Returns the OPENFILENAME structure.
+  const OPENFILENAME* GetOPENFILENAME() const { return &openfilename_; }
+
+  // Stores directory and filenames in the buffer pointed to by
+  // |openfilename->lpstrFile| and sized |openfilename->nMaxFile|.
+  static void SetResult(const base::FilePath& directory,
+                        const std::vector<base::FilePath>& filenames,
+                        OPENFILENAME* openfilename);
+
+  // Returns a vector of label/pattern pairs built from
+  // |openfilename->lpstrFilter|.
+  static std::vector<std::tuple<std::wstring, std::wstring>> GetFilters(
+      const OPENFILENAME* openfilename);
+
+ private:
+  OPENFILENAME openfilename_;
+  std::wstring initial_directory_buffer_;
+  wchar_t filename_buffer_[UNICODE_STRING_MAX_CHARS];
+  std::wstring filter_buffer_;
+};
+
+}  // namespace win
+}  // namespace ui
+
+#endif  // UI_BASE_WIN_OPEN_FILE_NAME_WIN_H_
+
+#include "base/files/file_path.h"
+#include "base/strings/string_util.h"
+#include "base/win/windows_version.h"
+
+namespace ui {
+namespace win {
+
+namespace {
+
+// Ensures that the Save As dialog is on-screen.
+UINT_PTR CALLBACK SaveAsDialogHook(HWND dialog, UINT message,
+                                   WPARAM wparam, LPARAM lparam) {
+  static const UINT kPrivateMessage = 0x2F3F;
+  switch (message) {
+    case WM_INITDIALOG: {
+      // Do nothing here. Just post a message to defer actual processing.
+      ::PostMessage(dialog, kPrivateMessage, 0, 0);
+      return TRUE;
+    }
+    case kPrivateMessage: {
+      // The dialog box is the parent of the current handle.
+      HWND real_dialog = ::GetParent(dialog);
+
+      // Retrieve the final size.
+      RECT dialog_rect;
+      ::GetWindowRect(real_dialog, &dialog_rect);
+
+      // Verify that the upper left corner is visible.
+      POINT point = { dialog_rect.left, dialog_rect.top };
+      HMONITOR monitor1 = ::MonitorFromPoint(point, MONITOR_DEFAULTTONULL);
+      point.x = dialog_rect.right;
+      point.y = dialog_rect.bottom;
+
+      // Verify that the lower right corner is visible.
+      HMONITOR monitor2 = ::MonitorFromPoint(point, MONITOR_DEFAULTTONULL);
+      if (monitor1 && monitor2)
+        return 0;
+
+      // Some part of the dialog box is not visible, fix it by moving is to the
+      // client rect position of the browser window.
+      HWND parent_window = ::GetParent(real_dialog);
+      if (!parent_window)
+        return 0;
+      WINDOWINFO parent_info;
+      parent_info.cbSize = sizeof(WINDOWINFO);
+      ::GetWindowInfo(parent_window, &parent_info);
+      ::SetWindowPos(
+          real_dialog,
+          NULL,
+          parent_info.rcClient.left,
+          parent_info.rcClient.top,
+          0,
+          0,  // Size.
+          SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOSIZE | SWP_NOZORDER);
+
+      return 0;
+    }
+  }
+  return 0;
+}
+
+}  // namespace
+
+OpenFileName::OpenFileName(HWND parent_window, DWORD flags) {
+  ::ZeroMemory(&openfilename_, sizeof(openfilename_));
+  openfilename_.lStructSize = sizeof(openfilename_);
+
+  // According to http://support.microsoft.com/?scid=kb;en-us;222003&x=8&y=12,
+  // The lpstrFile Buffer MUST be NULL Terminated.
+  filename_buffer_[0] = 0;
+  openfilename_.lpstrFile = filename_buffer_;
+  openfilename_.nMaxFile = std::size(filename_buffer_);
+
+  openfilename_.Flags = flags;
+  openfilename_.hwndOwner = parent_window;
+}
+
+OpenFileName::~OpenFileName() {
+}
+
+void OpenFileName::SetFilters(
+    const std::vector<FileFilterSpec>& filters) {
+  openfilename_.lpstrFilter = NULL;
+  filter_buffer_.clear();
+  if (filters.empty())
+    return;
+  for (const auto& filter : filters) {
+    filter_buffer_.append(base::as_wcstr(filter.description));
+    filter_buffer_.push_back(0);
+    filter_buffer_.append(base::as_wcstr(filter.extension_spec));
+    filter_buffer_.push_back(0);
+  }
+  filter_buffer_.push_back(0);
+  openfilename_.lpstrFilter = filter_buffer_.c_str();
+}
+
+void OpenFileName::SetInitialSelection(const base::FilePath& initial_directory,
+                                       const base::FilePath& initial_filename) {
+  // First reset to the default case.
+  // According to http://support.microsoft.com/?scid=kb;en-us;222003&x=8&y=12,
+  // The lpstrFile Buffer MUST be NULL Terminated.
+  filename_buffer_[0] = 0;
+  openfilename_.lpstrFile = filename_buffer_;
+  openfilename_.nMaxFile = std::size(filename_buffer_);
+  openfilename_.lpstrInitialDir = NULL;
+  initial_directory_buffer_.clear();
+
+  if (initial_directory.empty())
+    return;
+
+  initial_directory_buffer_ = initial_directory.value();
+  openfilename_.lpstrInitialDir = initial_directory_buffer_.c_str();
+
+  if (initial_filename.empty())
+    return;
+
+  // The filename is ignored if no initial directory is supplied.
+  base::wcslcpy(filename_buffer_,
+                initial_filename.value().c_str(),
+                std::size(filename_buffer_));
+}
+
+void OpenFileName::MaybeInstallWindowPositionHookForSaveAsOnXP() {
+  if (base::win::GetVersion() >= base::win::Version::VISTA)
+    return;
+
+  openfilename_.Flags |= OFN_ENABLEHOOK;
+  DCHECK(!openfilename_.lpfnHook);
+  openfilename_.lpfnHook = &SaveAsDialogHook;
+}
+
+base::FilePath OpenFileName::GetSingleResult() {
+  base::FilePath directory;
+  std::vector<base::FilePath> filenames;
+  GetResult(&directory, &filenames);
+  if (filenames.size() != 1)
+    return base::FilePath();
+  return directory.Append(filenames[0]);
+}
+
+void OpenFileName::GetResult(base::FilePath* directory,
+                             std::vector<base::FilePath>* filenames) {
+  DCHECK(filenames->empty());
+  const wchar_t* selection = openfilename_.lpstrFile;
+  // The return value of |openfilename_.lpstrFile| is dependent on the
+  // value of the Multi-Select flag within |openfilename_|. If the flag is
+  // not set the return value will be a single null-terminated wide string.
+  // If it is set it will be more than one null-terminated wide string, itself
+  // terminated by an empty null-terminated wide string.
+  if (openfilename_.Flags & OFN_ALLOWMULTISELECT) {
+    while (*selection) {  // Empty string indicates end of list.
+      filenames->push_back(base::FilePath(selection));
+      // Skip over filename and null-terminator.
+      selection += filenames->back().value().length() + 1;
+    }
+  } else {
+    filenames->push_back(base::FilePath(selection));
+  }
+  if (filenames->size() == 1) {
+    // When there is one file, it contains the path and filename.
+    *directory = (*filenames)[0].DirName();
+    (*filenames)[0] = (*filenames)[0].BaseName();
+  } else if (filenames->size() > 1) {
+    // Otherwise, the first string is the path, and the remainder are
+    // filenames.
+    *directory = (*filenames)[0];
+    filenames->erase(filenames->begin());
+  }
+}
+
+// static
+void OpenFileName::SetResult(const base::FilePath& directory,
+                             const std::vector<base::FilePath>& filenames,
+                             OPENFILENAME* openfilename) {
+  std::wstring filename_value;
+  if (filenames.size() == 1) {
+    filename_value = directory.Append(filenames[0]).value();
+  } else {
+    filename_value = directory.value();
+    filename_value.push_back(0);
+    for (std::vector<base::FilePath>::const_iterator it = filenames.begin();
+         it != filenames.end();
+         ++it) {
+      filename_value.append(it->value());
+      filename_value.push_back(0);
+    }
+  }
+  if (filename_value.size() + 1 < openfilename->nMaxFile) {
+    // Because the result has embedded nulls, we must memcpy.
+    memcpy(openfilename->lpstrFile,
+           filename_value.c_str(),
+           (filename_value.size() + 1) * sizeof(filename_value[0]));
+  } else if (openfilename->nMaxFile) {
+    openfilename->lpstrFile[0] = 0;
+  }
+}
+
+// static
+std::vector<std::tuple<std::wstring, std::wstring>>
+OpenFileName::GetFilters(const OPENFILENAME* openfilename) {
+  std::vector<std::tuple<std::wstring, std::wstring>> filters;
+
+  const wchar_t* display_string = openfilename->lpstrFilter;
+  if (!display_string)
+    return filters;
+
+  while (*display_string) {
+    const wchar_t* display_string_end = display_string;
+    while (*display_string_end)
+      ++display_string_end;
+    const wchar_t* pattern = display_string_end + 1;
+    const wchar_t* pattern_end = pattern;
+    while (*pattern_end)
+      ++pattern_end;
+    filters.push_back(
+        std::make_tuple(std::wstring(display_string, display_string_end),
+                  std::wstring(pattern, pattern_end)));
+    display_string = pattern_end + 1;
+  }
+
+  return filters;
+}
+
+}  // namespace win
+}  // namespace ui
 namespace ui {
 
 namespace {
@@ -31,6 +345,52 @@ bool IsDirectory(const base::FilePath& path) {
                                              : path.EndsWithSeparator();
 }
 
+// Given |extension|, if it's not empty, then remove the leading dot.
+std::wstring GetExtensionWithoutLeadingDot(const std::wstring& extension) {
+  DCHECK(extension.empty() || extension[0] == L'.');
+  return extension.empty() ? extension : extension.substr(1);
+}
+
+// This function takes the output of a SaveAs dialog: a filename, a filter and
+// the extension originally suggested to the user (shown in the dialog box) and
+// returns back the filename with the appropriate extension appended. If the
+// user requests an unknown extension and is not using the 'All files' filter,
+// the suggested extension will be appended, otherwise we will leave the
+// filename unmodified. |filename| should contain the filename selected in the
+// SaveAs dialog box and may include the path, |filter_selected| should be
+// '*.something', for example '*.*' or it can be blank (which is treated as
+// *.*). |suggested_ext| should contain the extension without the dot (.) in
+// front, for example 'jpg'.
+std::wstring AppendExtensionIfNeeded(const std::wstring& filename,
+                                     const std::wstring& filter_selected,
+                                     const std::wstring& suggested_ext) {
+  DCHECK(!filename.empty());
+  std::wstring return_value = filename;
+
+  // If we wanted a specific extension, but the user's filename deleted it or
+  // changed it to something that the system doesn't understand, re-append.
+  // Careful: Checking net::GetMimeTypeFromExtension() will only find
+  // extensions with a known MIME type, which many "known" extensions on Windows
+  // don't have.  So we check directly for the "known extension" registry key.
+  std::wstring file_extension(
+      GetExtensionWithoutLeadingDot(base::FilePath(filename).Extension()));
+  std::wstring key(L"." + file_extension);
+  if (!(filter_selected.empty() || filter_selected == L"*.*") &&
+      !base::win::RegKey(HKEY_CLASSES_ROOT, key.c_str(), KEY_READ).Valid() &&
+      file_extension != suggested_ext) {
+    if (return_value.back() != L'.')
+      return_value.append(L".");
+    return_value.append(suggested_ext);
+  }
+
+  // Strip any trailing dots, which Windows doesn't allow.
+  size_t index = return_value.find_last_not_of(L'.');
+  if (index < return_value.size() - 1)
+    return_value.resize(index + 1);
+
+  return return_value;
+}
+
 // Sets which path is going to be open when the dialog will be shown. If
 // |default_path| is not only a directory, also sets the contents of the text
 // box equals to the basename of the path.
@@ -322,6 +639,251 @@ bool ExecuteSaveFile(HWND owner,
                            def_ext, filter_index, path);
 }
 
+struct SelectFolderDialogOptions {
+  const wchar_t* default_path;
+  bool is_upload;
+};
+
+// Prompt the user for location to save a file.
+// Callers should provide the filter string, and also a filter index.
+// The parameter |index| indicates the initial index of filter description and
+// filter pattern for the dialog box. If |index| is zero or greater than the
+// number of total filter types, the system uses the first filter in the
+// |filter| buffer. |index| is used to specify the initial selected extension,
+// and when done contains the extension the user chose. The parameter |path|
+// returns the file name which contains the drive designator, path, file name,
+// and extension of the user selected file name. |def_ext| is the default
+// extension to give to the file if the user did not enter an extension.
+bool SaveFileAsWithFilter(HWND owner,
+                          const base::FilePath& default_path,
+                          const std::vector<FileFilterSpec>& filter,
+                          const std::wstring& def_ext,
+                          DWORD* index,
+                          base::FilePath* path) {
+  DCHECK(path);
+  // Having an empty filter makes for a bad user experience. We should always
+  // specify a filter when saving.
+  DCHECK(!filter.empty());
+
+  ui::win::OpenFileName save_as(owner, OFN_OVERWRITEPROMPT | OFN_EXPLORER |
+                                           OFN_ENABLESIZING | OFN_NOCHANGEDIR |
+                                           OFN_PATHMUSTEXIST);
+
+  if (!default_path.empty()) {
+    base::FilePath suggested_file_name;
+    base::FilePath suggested_directory;
+    if (IsDirectory(default_path)) {
+      suggested_directory = default_path;
+    } else {
+      suggested_directory = default_path.DirName();
+      suggested_file_name = default_path.BaseName();
+      // If the default_path is a root directory, |suggested_file_name| will be
+      // '\', and the call to GetSaveFileName below will fail.
+      if (suggested_file_name.value() == L"\\")
+        suggested_file_name.clear();
+    }
+    save_as.SetInitialSelection(suggested_directory, suggested_file_name);
+  }
+
+  save_as.SetFilters(filter);
+  save_as.GetOPENFILENAME()->nFilterIndex = *index;
+  save_as.GetOPENFILENAME()->lpstrDefExt = &def_ext[0];
+
+  BOOL success = ::GetSaveFileName(save_as.GetOPENFILENAME());
+  BaseShellDialogImpl::DisableOwner(owner);
+  if (!success)
+    return false;
+
+  // Return the user's choice.
+  *path = base::FilePath(save_as.GetOPENFILENAME()->lpstrFile);
+  *index = save_as.GetOPENFILENAME()->nFilterIndex;
+
+  // Figure out what filter got selected. The filter index is 1-based.
+  std::wstring filter_selected;
+  if (*index > 0) {
+    std::vector<std::tuple<std::wstring, std::wstring>> filters =
+        ui::win::OpenFileName::GetFilters(save_as.GetOPENFILENAME());
+    if (*index > filters.size())
+      NOTREACHED() << "Invalid filter index.";
+    else
+      filter_selected = std::get<1>(filters[*index - 1]);
+  }
+
+  // Get the extension that was suggested to the user (when the Save As dialog
+  // was opened).
+  std::wstring suggested_ext =
+      GetExtensionWithoutLeadingDot(default_path.Extension());
+
+  // If we can't get the extension from the default_path, we use the default
+  // extension passed in. This is to cover cases like when saving a web page,
+  // where we get passed in a name without an extension and a default extension
+  // along with it.
+  if (suggested_ext.empty())
+    suggested_ext = def_ext;
+
+  *path = base::FilePath(
+      AppendExtensionIfNeeded(path->value(), filter_selected, suggested_ext));
+  return true;
+}
+
+int CALLBACK BrowseCallbackProc(HWND window,
+                                UINT message,
+                                LPARAM parameter,
+                                LPARAM data) {
+  if (message == BFFM_INITIALIZED) {
+    SelectFolderDialogOptions* options =
+        reinterpret_cast<SelectFolderDialogOptions*>(data);
+    if (options->is_upload) {
+      SendMessage(window, BFFM_SETOKTEXT, 0,
+                  reinterpret_cast<LPARAM>(
+                      l10n_util::GetStringUTF16(
+                          IDS_SELECT_UPLOAD_FOLDER_DIALOG_UPLOAD_BUTTON)
+                          .c_str()));
+    }
+    if (options->default_path) {
+      SendMessage(window, BFFM_SETSELECTION, TRUE,
+                  reinterpret_cast<LPARAM>(options->default_path));
+    }
+  }
+  return 0;
+}
+
+// Runs a Folder selection dialog box, passes back the selected folder in |path|
+// and returns true if the user clicks OK. If the user cancels the dialog box
+// the value in |path| is not modified and returns false. Run on the dialog
+// thread.
+bool RunSelectFolderDialog(HWND owner,
+                           SelectFileDialog::Type type,
+                           const std::u16string& title,
+                           const base::FilePath& default_path,
+                           base::FilePath* path) {
+  base::win::AssertComInitialized();
+  DCHECK(path);
+  std::u16string new_title = title;
+  if (new_title.empty() && type == SelectFileDialog::SELECT_UPLOAD_FOLDER) {
+    // If it's for uploading don't use default dialog title to
+    // make sure we clearly tell it's for uploading.
+    new_title =
+        l10n_util::GetStringUTF16(IDS_SELECT_UPLOAD_FOLDER_DIALOG_TITLE);
+  }
+
+  wchar_t dir_buffer[MAX_PATH + 1];
+
+  bool result = false;
+  BROWSEINFO browse_info = {};
+  browse_info.hwndOwner = owner;
+  browse_info.lpszTitle = base::as_wcstr(new_title.c_str());
+  browse_info.pszDisplayName = dir_buffer;
+  browse_info.ulFlags = BIF_USENEWUI | BIF_RETURNONLYFSDIRS;
+
+  // If uploading or a default path was provided, update the BROWSEINFO
+  // and set the callback function for the dialog so the strings can be set in
+  // the callback.
+  SelectFolderDialogOptions dialog_options = {};
+  if (!default_path.empty())
+    dialog_options.default_path = default_path.value().c_str();
+  dialog_options.is_upload = type == SelectFileDialog::SELECT_UPLOAD_FOLDER;
+  if (type == SelectFileDialog::SELECT_UPLOAD_FOLDER ||
+      type == SelectFileDialog::SELECT_EXISTING_FOLDER) {
+    browse_info.ulFlags |= BIF_NONEWFOLDERBUTTON;
+  }
+  if (dialog_options.is_upload || dialog_options.default_path) {
+    browse_info.lParam = reinterpret_cast<LPARAM>(&dialog_options);
+    browse_info.lpfn = &BrowseCallbackProc;
+  }
+
+  LPITEMIDLIST list = SHBrowseForFolder(&browse_info);
+  BaseShellDialogImpl::DisableOwner(owner);
+  if (list) {
+    STRRET out_dir_buffer = {};
+    out_dir_buffer.uType = STRRET_WSTR;
+    Microsoft::WRL::ComPtr<IShellFolder> shell_folder;
+    if (SUCCEEDED(SHGetDesktopFolder(&shell_folder))) {
+      HRESULT hr = shell_folder->GetDisplayNameOf(list, SHGDN_FORPARSING,
+                                                  &out_dir_buffer);
+      if (SUCCEEDED(hr) && out_dir_buffer.uType == STRRET_WSTR) {
+        *path = base::FilePath(out_dir_buffer.pOleStr);
+        CoTaskMemFree(out_dir_buffer.pOleStr);
+        result = true;
+      } else {
+        // Use old way if we don't get what we want.
+        wchar_t old_out_dir_buffer[MAX_PATH + 1];
+        if (SHGetPathFromIDList(list, old_out_dir_buffer)) {
+          *path = base::FilePath(old_out_dir_buffer);
+          result = true;
+        }
+      }
+
+      // According to MSDN, Win2000 will not resolve shortcuts, so we do it
+      // ourselves.
+      base::win::ResolveShortcut(*path, path, nullptr);
+    }
+    CoTaskMemFree(list);
+  }
+  return result;
+}
+
+// Runs an Open file dialog box, with similar semantics for input parameters as
+// RunSelectFolderDialog.
+bool RunOpenFileDialog(HWND owner,
+                       const std::u16string& title,
+                       const base::FilePath& default_path,
+                       const std::vector<FileFilterSpec>& filter,
+                       base::FilePath* path) {
+  // We use OFN_NOCHANGEDIR so that the user can rename or delete the
+  // directory without having to close Chrome first.
+  ui::win::OpenFileName ofn(owner, OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR);
+  if (!default_path.empty()) {
+    if (IsDirectory(default_path))
+      ofn.SetInitialSelection(default_path, base::FilePath());
+    else
+      ofn.SetInitialSelection(default_path.DirName(), default_path.BaseName());
+  }
+  ofn.SetFilters(filter);
+
+  BOOL success = ::GetOpenFileName(ofn.GetOPENFILENAME());
+  BaseShellDialogImpl::DisableOwner(owner);
+  if (success)
+    *path = ofn.GetSingleResult();
+  return success;
+}
+
+// Runs an Open file dialog box that supports multi-select, with similar
+// semantics for input parameters as RunOpenFileDialog.
+bool RunOpenMultiFileDialog(HWND owner,
+                            const std::u16string& title,
+                            const base::FilePath& default_path,
+                            const std::vector<FileFilterSpec>& filter,
+                            std::vector<base::FilePath>* paths) {
+  // We use OFN_NOCHANGEDIR so that the user can rename or delete the directory
+  // without having to close Chrome first.
+  ui::win::OpenFileName ofn(owner, OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST |
+                                       OFN_EXPLORER | OFN_HIDEREADONLY |
+                                       OFN_ALLOWMULTISELECT | OFN_NOCHANGEDIR);
+  if (!default_path.empty()) {
+    if (IsDirectory(default_path))
+      ofn.SetInitialSelection(default_path, base::FilePath());
+    else
+      ofn.SetInitialSelection(default_path.DirName(), base::FilePath());
+  }
+  ofn.SetFilters(filter);
+
+  base::FilePath directory;
+  std::vector<base::FilePath> filenames;
+
+  BOOL success = ::GetOpenFileName(ofn.GetOPENFILENAME());
+  BaseShellDialogImpl::DisableOwner(owner);
+  if (success)
+    ofn.GetResult(&directory, &filenames);
+
+  for (std::vector<base::FilePath>::iterator it = filenames.begin();
+       it != filenames.end(); ++it) {
+    paths->push_back(directory.Append(*it));
+  }
+
+  return !paths->empty();
+}
+
 }  // namespace
 
 void ExecuteSelectFile(
@@ -378,25 +940,65 @@ void ExecuteSelectFile(
   switch (type) {
     case SelectFileDialog::SELECT_FOLDER:
     case SelectFileDialog::SELECT_UPLOAD_FOLDER:
-    case SelectFileDialog::SELECT_EXISTING_FOLDER:
+    case SelectFileDialog::SELECT_EXISTING_FOLDER: {
+  Microsoft::WRL::ComPtr<IFileOpenDialog> file_open_dialog;
+  if (FAILED(::CoCreateInstance(CLSID_FileOpenDialog, nullptr,
+                                CLSCTX_INPROC_SERVER,
+                                IID_PPV_ARGS(&file_open_dialog)))) {
+      base::FilePath path;
+      if (RunSelectFolderDialog(owner, type, title, default_path, &path))
+        paths.push_back(std::move(path));
+  }
+    else
       ExecuteSelectFolder(owner, type, title, default_path, &paths);
+    }
       break;
     case SelectFileDialog::SELECT_SAVEAS_FILE: {
       base::FilePath path;
+  Microsoft::WRL::ComPtr<IFileSaveDialog> file_save_dialog;
+  if (FAILED(::CoCreateInstance(CLSID_FileSaveDialog, nullptr,
+                                CLSCTX_INPROC_SERVER,
+                                IID_PPV_ARGS(&file_save_dialog)))) {
+  DWORD filter_index = file_type_index;
+      if (SaveFileAsWithFilter(owner, default_path, filter, default_extension,
+                               &filter_index, &path))
+        paths.push_back(std::move(path));
+     break;
+  }
+    else
       if (ExecuteSaveFile(owner, title, default_path, filter, default_extension,
                           &file_type_index, &path)) {
         paths.push_back(std::move(path));
       }
       break;
     }
-    case SelectFileDialog::SELECT_OPEN_FILE:
+    case SelectFileDialog::SELECT_OPEN_FILE: {
+  Microsoft::WRL::ComPtr<IFileOpenDialog> file_open_dialog;
+  if (FAILED(::CoCreateInstance(CLSID_FileOpenDialog, nullptr,
+                                CLSCTX_INPROC_SERVER,
+                                IID_PPV_ARGS(&file_open_dialog)))) {
+      base::FilePath path;
+      if (RunOpenFileDialog(owner, title, default_path, filter, &path))
+        paths.push_back(std::move(path));
+     break;
+  }
+    else
       ExecuteSelectSingleFile(owner, title, default_path, filter,
                               &file_type_index, &paths);
       break;
-    case SelectFileDialog::SELECT_OPEN_MULTI_FILE:
+    }
+    case SelectFileDialog::SELECT_OPEN_MULTI_FILE: {
+  Microsoft::WRL::ComPtr<IFileOpenDialog> file_open_dialog;
+  if (FAILED(::CoCreateInstance(CLSID_FileOpenDialog, nullptr,
+                                CLSCTX_INPROC_SERVER,
+                                IID_PPV_ARGS(&file_open_dialog)))) {
+      RunOpenMultiFileDialog(owner, title, default_path, filter, &paths);
+  }
+    else
       ExecuteSelectMultipleFile(owner, title, default_path, filter,
                                 &file_type_index, &paths);
+    }
       break;
     case SelectFileDialog::SELECT_NONE:
       NOTREACHED();
   }
