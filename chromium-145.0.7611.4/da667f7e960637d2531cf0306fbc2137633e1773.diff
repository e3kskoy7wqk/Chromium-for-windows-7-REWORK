diff --git a/chrome/app/chrome_exe_main_win.cc b/chrome/app/chrome_exe_main_win.cc
index 441282024743d..f06d9c9244923 100644
--- a/chrome/app/chrome_exe_main_win.cc
+++ b/chrome/app/chrome_exe_main_win.cc
@@ -59,6 +59,1325 @@
 int main();
 #endif
 
+#pragma comment(lib, "ntdll.lib")
+
+#ifdef __cplusplus
+extern "C" {                        /* Assume C declarations for C++. */
+#endif   /* __cplusplus */
+
+
+//
+// Logical Data Type - These are 32-bit logical values.
+//
+
+typedef ULONG LOGICAL;
+typedef ULONG *PLOGICAL;
+
+// begin_ntndis begin_windbgkd
+//
+// NTSTATUS
+//
+
+typedef LONG NTSTATUS;
+/*lint -save -e624 */  // Don't complain about different typedefs.
+typedef NTSTATUS *PNTSTATUS;
+/*lint -restore */  // Resume checking for different typedefs.
+
+//
+// Generic test for success on any status value (non-negative numbers
+// indicate success).
+//
+
+#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
+
+//
+// Unicode strings are counted 16-bit character strings. If they are
+// NULL terminated, Length does not include trailing NULL.
+//
+
+typedef struct _UNICODE_STRING {
+    USHORT Length;
+    USHORT MaximumLength;
+    PWSTR  Buffer;
+} UNICODE_STRING;
+typedef UNICODE_STRING *PUNICODE_STRING;
+typedef const UNICODE_STRING *PCUNICODE_STRING;
+#define UNICODE_NULL ((WCHAR)0) // winnt
+
+typedef struct _OBJECT_ATTRIBUTES {
+    ULONG Length;
+    HANDLE RootDirectory;
+    PUNICODE_STRING ObjectName;
+    ULONG Attributes;
+    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
+    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
+} OBJECT_ATTRIBUTES;
+typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
+typedef CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;
+
+//++
+//
+// VOID
+// InitializeObjectAttributes(
+//     OUT POBJECT_ATTRIBUTES p,
+//     IN PUNICODE_STRING n,
+//     IN ULONG a,
+//     IN HANDLE r,
+//     IN PSECURITY_DESCRIPTOR s
+//     )
+//
+//--
+
+#define InitializeObjectAttributes( p, n, a, r, s ) { \
+    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
+    (p)->RootDirectory = r;                             \
+    (p)->Attributes = a;                                \
+    (p)->ObjectName = n;                                \
+    (p)->SecurityDescriptor = s;                        \
+    (p)->SecurityQualityOfService = NULL;               \
+    }
+
+//
+// Status Code Definitions
+//
+
+#define STATUS_SUCCESS 0x0
+#define STATUS_INFO_LENGTH_MISMATCH 0xc0000004
+
+//
+// Thread priority
+//
+
+typedef LONG KPRIORITY;
+
+struct _TEB *
+NtCurrentTeb(void);
+//
+// Loader Data Table. Used to track DLLs loaded into an
+// image.
+//
+
+typedef struct _LDR_DATA_TABLE_ENTRY {
+    LIST_ENTRY InLoadOrderLinks;
+    LIST_ENTRY InMemoryOrderLinks;
+    LIST_ENTRY InInitializationOrderLinks;
+    PVOID DllBase;
+    PVOID EntryPoint;
+    ULONG SizeOfImage;
+    UNICODE_STRING FullDllName;
+    UNICODE_STRING BaseDllName;
+    ULONG Flags;
+    USHORT LoadCount;
+    USHORT TlsIndex;
+    union {
+        LIST_ENTRY HashLinks;
+        struct {
+            PVOID SectionPointer;
+            ULONG CheckSum;
+        };
+    };
+    union {
+        struct {
+            ULONG TimeDateStamp;
+        };
+        struct {
+            PVOID LoadedImports;
+        };
+    };
+    struct _ACTIVATION_CONTEXT * EntryPointActivationContext;
+
+    PVOID PatchInformation;
+
+} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
+
+//
+// Process Environment Block
+//
+#ifdef _MAC
+#pragma warning( disable : 4121)
+#endif
+
+typedef struct _PEB_LDR_DATA {
+    ULONG Length;
+    BOOLEAN Initialized;
+    HANDLE SsHandle;
+    LIST_ENTRY InLoadOrderModuleList;
+    LIST_ENTRY InMemoryOrderModuleList;
+    LIST_ENTRY InInitializationOrderModuleList;
+    PVOID EntryInProgress;
+} PEB_LDR_DATA, *PPEB_LDR_DATA;
+
+#ifdef _MAC
+#pragma warning( default : 4121 )
+#endif
+//
+// Handle tag bits for Peb Stdio File Handles
+//
+
+#define PEB_STDIO_HANDLE_NATIVE     0
+#define PEB_STDIO_HANDLE_SUBSYS     1
+#define PEB_STDIO_HANDLE_PM         2
+#define PEB_STDIO_HANDLE_RESERVED   3
+
+#define GDI_HANDLE_BUFFER_SIZE32  34
+#define GDI_HANDLE_BUFFER_SIZE64  60
+
+#if !defined(_IA64_) && !defined(_AMD64_)
+#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE32
+#else
+#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE64
+#endif
+
+typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
+typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
+typedef ULONG GDI_HANDLE_BUFFER  [GDI_HANDLE_BUFFER_SIZE  ];
+
+#define FOREGROUND_BASE_PRIORITY  9
+#define NORMAL_BASE_PRIORITY      8
+
+typedef struct _PEB_FREE_BLOCK {
+    struct _PEB_FREE_BLOCK *Next;
+    ULONG Size;
+} PEB_FREE_BLOCK, *PPEB_FREE_BLOCK;
+
+// begin_ntddk begin_wdm begin_nthal begin_ntifs
+//
+// ClientId
+//
+
+typedef struct _CLIENT_ID {
+    HANDLE UniqueProcess;
+    HANDLE UniqueThread;
+} CLIENT_ID;
+typedef CLIENT_ID *PCLIENT_ID;
+
+// end_ntddk end_wdm end_nthal end_ntifs
+
+#if !defined(CLIENT_ID64_DEFINED)
+
+typedef struct _CLIENT_ID64 {
+    ULONGLONG  UniqueProcess;
+    ULONGLONG  UniqueThread;
+} CLIENT_ID64;
+
+typedef CLIENT_ID64 *PCLIENT_ID64;
+
+#define CLIENT_ID64_DEFINED
+
+#endif
+
+#define TLS_MINIMUM_AVAILABLE 64    // winnt
+#define TLS_EXPANSION_SLOTS   1024
+
+typedef
+VOID
+(*PPS_POST_PROCESS_INIT_ROUTINE) (
+    VOID
+    );
+
+//
+// Gdi command batching
+//
+
+#define GDI_BATCH_BUFFER_SIZE 310
+
+typedef struct _GDI_TEB_BATCH {
+    ULONG    Offset;
+    ULONG_PTR HDC;
+    ULONG    Buffer[GDI_BATCH_BUFFER_SIZE];
+} GDI_TEB_BATCH,*PGDI_TEB_BATCH;
+
+
+//
+// Wx86 thread state information
+//
+
+typedef struct _Wx86ThreadState {
+    PULONG  CallBx86Eip;
+    PVOID   DeallocationCpu;
+    BOOLEAN UseKnownWx86Dll;
+    char    OleStubInvoked;
+} WX86THREAD, *PWX86THREAD;
+
+//
+//  TEB - The thread environment block
+//
+
+#define STATIC_UNICODE_BUFFER_LENGTH 261
+#define WIN32_CLIENT_INFO_LENGTH 62
+
+#define WIN32_CLIENT_INFO_SPIN_COUNT 1
+
+typedef PVOID* PPVOID;
+
+#define PEBTEB_PRIVATE_PASTE(x,y)       x##y
+#define PEBTEB_PASTE(x,y)               PEBTEB_PRIVATE_PASTE(x,y)
+
+//
+// Declare and use regular native types.
+//
+#define PEBTEB_POINTER(x) x
+#define PEBTEB_STRUCT(x)  x
+
+/* for searching
+typedef struct _PEB
+typedef struct _PEB32
+typedef struct _PEB64
+*/
+typedef struct PEBTEB_STRUCT(_PEB) {
+    BOOLEAN InheritedAddressSpace;      // These four fields cannot change unless the
+    BOOLEAN ReadImageFileExecOptions;   //
+    BOOLEAN BeingDebugged;              //
+    BOOLEAN SpareBool;                  //
+    PEBTEB_POINTER(HANDLE) Mutant;      // INITIAL_PEB structure is also updated.
+
+    PEBTEB_POINTER(PVOID) ImageBaseAddress;
+    PEBTEB_POINTER(PPEB_LDR_DATA) Ldr;
+    PEBTEB_POINTER(struct _RTL_USER_PROCESS_PARAMETERS*) ProcessParameters;
+    PEBTEB_POINTER(PVOID) SubSystemData;
+    PEBTEB_POINTER(PVOID) ProcessHeap;
+    PEBTEB_POINTER(struct _RTL_CRITICAL_SECTION*) FastPebLock;
+    PEBTEB_POINTER(PVOID) SparePtr1;
+    PEBTEB_POINTER(PVOID) SparePtr2;
+    ULONG EnvironmentUpdateCount;
+    PEBTEB_POINTER(PVOID) KernelCallbackTable;
+    ULONG SystemReserved[1];
+
+    struct {
+        ULONG ExecuteOptions : 2;
+        ULONG SpareBits : 30;
+    };
+
+
+    PEBTEB_POINTER(PPEB_FREE_BLOCK) FreeList;
+    ULONG TlsExpansionCounter;
+    PEBTEB_POINTER(PVOID) TlsBitmap;
+    ULONG TlsBitmapBits[2];         // TLS_MINIMUM_AVAILABLE bits
+    PEBTEB_POINTER(PVOID) ReadOnlySharedMemoryBase;
+    PEBTEB_POINTER(PVOID) ReadOnlySharedMemoryHeap;
+    PEBTEB_POINTER(PPVOID) ReadOnlyStaticServerData;
+    PEBTEB_POINTER(PVOID) AnsiCodePageData;
+    PEBTEB_POINTER(PVOID) OemCodePageData;
+    PEBTEB_POINTER(PVOID) UnicodeCaseTableData;
+
+    //
+    // Useful information for LdrpInitialize
+    ULONG NumberOfProcessors;
+    ULONG NtGlobalFlag;
+
+    //
+    // Passed up from MmCreatePeb from Session Manager registry key
+    //
+
+    LARGE_INTEGER CriticalSectionTimeout;
+    PEBTEB_POINTER(SIZE_T) HeapSegmentReserve;
+    PEBTEB_POINTER(SIZE_T) HeapSegmentCommit;
+    PEBTEB_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
+    PEBTEB_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;
+
+    //
+    // Where heap manager keeps track of all heaps created for a process
+    // Fields initialized by MmCreatePeb.  ProcessHeaps is initialized
+    // to point to the first free byte after the PEB and MaximumNumberOfHeaps
+    // is computed from the page size used to hold the PEB, less the fixed
+    // size of this data structure.
+    //
+
+    ULONG NumberOfHeaps;
+    ULONG MaximumNumberOfHeaps;
+    PEBTEB_POINTER(PPVOID) ProcessHeaps;
+
+    //
+    //
+    PEBTEB_POINTER(PVOID) GdiSharedHandleTable;
+    PEBTEB_POINTER(PVOID) ProcessStarterHelper;
+    ULONG GdiDCAttributeList;
+    PEBTEB_POINTER(struct _RTL_CRITICAL_SECTION*) LoaderLock;
+
+    //
+    // Following fields filled in by MmCreatePeb from system values and/or
+    // image header.
+    //
+
+    ULONG OSMajorVersion;
+    ULONG OSMinorVersion;
+    USHORT OSBuildNumber;
+    USHORT OSCSDVersion;
+    ULONG OSPlatformId;
+    ULONG ImageSubsystem;
+    ULONG ImageSubsystemMajorVersion;
+    ULONG ImageSubsystemMinorVersion;
+    PEBTEB_POINTER(ULONG_PTR) ImageProcessAffinityMask;
+    PEBTEB_STRUCT(GDI_HANDLE_BUFFER) GdiHandleBuffer;
+    PEBTEB_POINTER(PPS_POST_PROCESS_INIT_ROUTINE) PostProcessInitRoutine;
+
+    PEBTEB_POINTER(PVOID) TlsExpansionBitmap;
+    ULONG TlsExpansionBitmapBits[32];   // TLS_EXPANSION_SLOTS bits
+
+    //
+    // Id of the Hydra session in which this process is running
+    //
+    ULONG SessionId;
+
+    //
+    // Filled in by LdrpInstallAppcompatBackend
+    //
+    ULARGE_INTEGER AppCompatFlags;
+
+    //
+    // ntuser appcompat flags
+    //
+    ULARGE_INTEGER AppCompatFlagsUser;
+
+    //
+    // Filled in by LdrpInstallAppcompatBackend
+    //
+    PEBTEB_POINTER(PVOID) pShimData;
+
+    //
+    // Filled in by LdrQueryImageFileExecutionOptions
+    //
+    PEBTEB_POINTER(PVOID) AppCompatInfo;
+
+    //
+    // Used by GetVersionExW as the szCSDVersion string
+    //
+    PEBTEB_STRUCT(UNICODE_STRING) CSDVersion;
+
+    //
+    // Fusion stuff
+    //
+    PEBTEB_POINTER(const struct _ACTIVATION_CONTEXT_DATA *) ActivationContextData;
+    PEBTEB_POINTER(struct _ASSEMBLY_STORAGE_MAP *) ProcessAssemblyStorageMap;
+    PEBTEB_POINTER(const struct _ACTIVATION_CONTEXT_DATA *) SystemDefaultActivationContextData;
+    PEBTEB_POINTER(struct _ASSEMBLY_STORAGE_MAP *) SystemAssemblyStorageMap;
+
+    //
+    // Enforced minimum initial commit stack
+    //
+    PEBTEB_POINTER(SIZE_T) MinimumStackCommit;
+
+    //
+    // Fiber local storage.
+    //
+
+    PEBTEB_POINTER(PPVOID) FlsCallback;
+    PEBTEB_STRUCT(LIST_ENTRY) FlsListHead;
+    PEBTEB_POINTER(PVOID) FlsBitmap;
+    ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
+    ULONG FlsHighIndex;
+} PEBTEB_STRUCT(PEB), * PEBTEB_STRUCT(PPEB);
+
+//
+//  Fusion/sxs thread state information
+//
+
+#define ACTIVATION_CONTEXT_STACK_FLAG_QUERIES_DISABLED (0x00000001)
+
+typedef struct PEBTEB_STRUCT(_ACTIVATION_CONTEXT_STACK) {
+    ULONG Flags;
+    ULONG NextCookieSequenceNumber;
+    PEBTEB_POINTER(struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME *) ActiveFrame;
+    PEBTEB_STRUCT(LIST_ENTRY) FrameListCache;
+} PEBTEB_STRUCT(ACTIVATION_CONTEXT_STACK), * PEBTEB_STRUCT(PACTIVATION_CONTEXT_STACK);
+
+typedef const PEBTEB_STRUCT(ACTIVATION_CONTEXT_STACK) * PEBTEB_STRUCT(PCACTIVATION_CONTEXT_STACK);
+
+#define TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED (0x00000001)
+
+typedef struct PEBTEB_STRUCT(_TEB_ACTIVE_FRAME_CONTEXT) {
+    ULONG Flags;
+    PEBTEB_POINTER(PCSTR) FrameName;
+} PEBTEB_STRUCT(TEB_ACTIVE_FRAME_CONTEXT), *PEBTEB_STRUCT(PTEB_ACTIVE_FRAME_CONTEXT);
+
+typedef const PEBTEB_STRUCT(TEB_ACTIVE_FRAME_CONTEXT) *PEBTEB_STRUCT(PCTEB_ACTIVE_FRAME_CONTEXT);
+
+typedef struct PEBTEB_STRUCT(_TEB_ACTIVE_FRAME_CONTEXT_EX) {
+    PEBTEB_STRUCT(TEB_ACTIVE_FRAME_CONTEXT) BasicContext;
+    PEBTEB_POINTER(PCSTR) SourceLocation; // e.g. "Z:\foo\bar\baz.c"
+} PEBTEB_STRUCT(TEB_ACTIVE_FRAME_CONTEXT_EX), *PEBTEB_STRUCT(PTEB_ACTIVE_FRAME_CONTEXT_EX);
+
+typedef const PEBTEB_STRUCT(TEB_ACTIVE_FRAME_CONTEXT_EX) *PEBTEB_STRUCT(PCTEB_ACTIVE_FRAME_CONTEXT_EX);
+
+#define TEB_ACTIVE_FRAME_FLAG_EXTENDED (0x00000001)
+
+typedef struct PEBTEB_STRUCT(_TEB_ACTIVE_FRAME) {
+    ULONG Flags;
+    PEBTEB_POINTER(struct _TEB_ACTIVE_FRAME*) Previous;
+    PEBTEB_POINTER(PCTEB_ACTIVE_FRAME_CONTEXT) Context;
+} PEBTEB_STRUCT(TEB_ACTIVE_FRAME), *PEBTEB_STRUCT(PTEB_ACTIVE_FRAME);
+
+typedef const PEBTEB_STRUCT(TEB_ACTIVE_FRAME) *PEBTEB_STRUCT(PCTEB_ACTIVE_FRAME);
+
+typedef struct PEBTEB_STRUCT(_TEB_ACTIVE_FRAME_EX) {
+    PEBTEB_STRUCT(TEB_ACTIVE_FRAME) BasicFrame;
+    PEBTEB_POINTER(PVOID) ExtensionIdentifier; // use address of your DLL Main or something unique to your mapping in the address space
+} PEBTEB_STRUCT(TEB_ACTIVE_FRAME_EX), *PEBTEB_STRUCT(PTEB_ACTIVE_FRAME_EX);
+
+typedef const PEBTEB_STRUCT(TEB_ACTIVE_FRAME_EX) *PEBTEB_STRUCT(PCTEB_ACTIVE_FRAME_EX);
+
+/* for searching
+typedef struct _TEB
+typedef struct _TEB32
+typedef struct _TEB64
+*/
+typedef struct PEBTEB_STRUCT(_TEB) {
+    PEBTEB_STRUCT(NT_TIB) NtTib;
+    PEBTEB_POINTER(PVOID) EnvironmentPointer;
+    PEBTEB_STRUCT(CLIENT_ID) ClientId;
+    PEBTEB_POINTER(PVOID) ActiveRpcHandle;
+    PEBTEB_POINTER(PVOID) ThreadLocalStoragePointer;
+    PEBTEB_POINTER(PPEB) ProcessEnvironmentBlock;
+    ULONG LastErrorValue;
+    ULONG CountOfOwnedCriticalSections;
+    PEBTEB_POINTER(PVOID) CsrClientThread;
+    PEBTEB_POINTER(PVOID) Win32ThreadInfo;          // PtiCurrent
+    ULONG User32Reserved[26];       // user32.dll items
+    ULONG UserReserved[5];          // Winsrv SwitchStack
+    PEBTEB_POINTER(PVOID) WOW32Reserved;            // used by WOW
+    LCID CurrentLocale;
+    ULONG FpSoftwareStatusRegister; // offset known by outsiders!
+    PEBTEB_POINTER(PVOID) SystemReserved1[54];      // Used by FP emulator
+    NTSTATUS ExceptionCode;         // for RaiseUserException
+    PEBTEB_STRUCT(ACTIVATION_CONTEXT_STACK) ActivationContextStack;   // Fusion activation stack
+    // sizeof(PEBTEB_POINTER(PVOID)) is a way to express processor-dependence, more generally than #ifdef _WIN64
+    UCHAR SpareBytes1[48 - sizeof(PEBTEB_POINTER(PVOID)) - sizeof(PEBTEB_STRUCT(ACTIVATION_CONTEXT_STACK))];
+    PEBTEB_STRUCT(GDI_TEB_BATCH) GdiTebBatch;      // Gdi batching
+    PEBTEB_STRUCT(CLIENT_ID) RealClientId;
+    PEBTEB_POINTER(HANDLE) GdiCachedProcessHandle;
+    ULONG GdiClientPID;
+    ULONG GdiClientTID;
+    PEBTEB_POINTER(PVOID) GdiThreadLocalInfo;
+    PEBTEB_POINTER(ULONG_PTR) Win32ClientInfo[WIN32_CLIENT_INFO_LENGTH]; // User32 Client Info
+    PEBTEB_POINTER(PVOID) glDispatchTable[233];     // OpenGL
+    PEBTEB_POINTER(ULONG_PTR) glReserved1[29];      // OpenGL
+    PEBTEB_POINTER(PVOID) glReserved2;              // OpenGL
+    PEBTEB_POINTER(PVOID) glSectionInfo;            // OpenGL
+    PEBTEB_POINTER(PVOID) glSection;                // OpenGL
+    PEBTEB_POINTER(PVOID) glTable;                  // OpenGL
+    PEBTEB_POINTER(PVOID) glCurrentRC;              // OpenGL
+    PEBTEB_POINTER(PVOID) glContext;                // OpenGL
+    ULONG LastStatusValue;
+    PEBTEB_STRUCT(UNICODE_STRING) StaticUnicodeString;
+    WCHAR StaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
+    PEBTEB_POINTER(PVOID) DeallocationStack;
+    PEBTEB_POINTER(PVOID) TlsSlots[TLS_MINIMUM_AVAILABLE];
+    PEBTEB_STRUCT(LIST_ENTRY) TlsLinks;
+    PEBTEB_POINTER(PVOID) Vdm;
+    PEBTEB_POINTER(PVOID) ReservedForNtRpc;
+    PEBTEB_POINTER(PVOID) DbgSsReserved[2];
+    ULONG HardErrorMode;
+    PEBTEB_POINTER(PVOID) Instrumentation[16];
+    PEBTEB_POINTER(PVOID) WinSockData;              // WinSock
+    ULONG GdiBatchCount;
+    BOOLEAN InDbgPrint;
+    BOOLEAN FreeStackOnTermination;
+    BOOLEAN HasFiberData;
+    BOOLEAN IdealProcessor;
+    ULONG Spare3;
+    PEBTEB_POINTER(PVOID) ReservedForPerf;
+    PEBTEB_POINTER(PVOID) ReservedForOle;
+    ULONG WaitingOnLoaderLock;
+    PEBTEB_STRUCT(WX86THREAD) Wx86Thread;
+    PEBTEB_POINTER(PPVOID) TlsExpansionSlots;
+#if (defined(_WIN64) && !defined(PEBTEB_BITS)) \
+    || ((defined(_WIN64) || defined(_X86_)) && defined(PEBTEB_BITS) && PEBTEB_BITS == 64)
+    //
+    // These are in native Win64 TEB, Win64 TEB64, and x86 TEB64.
+    //
+    PEBTEB_POINTER(PVOID) DeallocationBStore;
+    PEBTEB_POINTER(PVOID) BStoreLimit;
+#endif
+    LCID ImpersonationLocale;       // Current locale of impersonated user
+    ULONG IsImpersonating;          // Thread impersonation status
+    PEBTEB_POINTER(PVOID) NlsCache;                 // NLS thread cache
+    PEBTEB_POINTER(PVOID) pShimData;                // Per thread data used in the shim
+    ULONG HeapVirtualAffinity;
+    PEBTEB_POINTER(HANDLE) CurrentTransactionHandle;// reserved for TxF transaction context
+    PEBTEB_POINTER(PTEB_ACTIVE_FRAME) ActiveFrame;
+    PEBTEB_POINTER(PVOID) FlsData;
+
+} PEBTEB_STRUCT(TEB), *PEBTEB_STRUCT(PTEB);
+
+#undef PEBTEB_POINTER
+#undef PEBTEB_STRUCT
+#undef PEBTEB_PRIVATE_PASTE
+#undef PEBTEB_PASTE
+//
+// Thread Information Classes
+//
+
+typedef enum _THREADINFOCLASS {
+    ThreadBasicInformation,
+    ThreadTimes,
+    ThreadPriority,
+    ThreadBasePriority,
+    ThreadAffinityMask,
+    ThreadImpersonationToken,
+    ThreadDescriptorTableEntry,
+    ThreadEnableAlignmentFaultFixup,
+    ThreadEventPair_Reusable,
+    ThreadQuerySetWin32StartAddress,
+    ThreadZeroTlsCell,
+    ThreadPerformanceCount,
+    ThreadAmILastThread,
+    ThreadIdealProcessor,
+    ThreadPriorityBoost,
+    ThreadSetTlsArrayAddress,
+    ThreadIsIoPending,
+    ThreadHideFromDebugger,
+    ThreadBreakOnTermination,
+    MaxThreadInfoClass
+    } THREADINFOCLASS;
+//
+// Basic Thread Information
+//  NtQueryInformationThread using ThreadBasicInfo
+//
+
+typedef struct _THREAD_BASIC_INFORMATION {
+    NTSTATUS ExitStatus;
+    PTEB TebBaseAddress;
+    CLIENT_ID ClientId;
+    ULONG_PTR AffinityMask;
+    KPRIORITY Priority;
+    LONG BasePriority;
+} THREAD_BASIC_INFORMATION;
+typedef THREAD_BASIC_INFORMATION *PTHREAD_BASIC_INFORMATION;
+
+#define NtCurrentPeb() (NtCurrentTeb()->ProcessEnvironmentBlock)
+
+NTSYSCALLAPI
+NTSTATUS
+NTAPI
+NtOpenThread (
+    OUT PHANDLE ThreadHandle,
+    IN ACCESS_MASK DesiredAccess,
+    IN POBJECT_ATTRIBUTES ObjectAttributes,
+    IN PCLIENT_ID ClientId OPTIONAL
+    );
+
+NTSYSCALLAPI
+NTSTATUS
+NTAPI
+NtQueryInformationThread(
+    IN HANDLE ThreadHandle,
+    IN THREADINFOCLASS ThreadInformationClass,
+    OUT PVOID ThreadInformation,
+    IN ULONG ThreadInformationLength,
+    OUT PULONG ReturnLength OPTIONAL
+    );
+
+//
+// System Information Classes.
+//
+
+typedef enum _SYSTEM_INFORMATION_CLASS {
+    SystemBasicInformation,
+    SystemProcessorInformation,             // obsolete...delete
+    SystemPerformanceInformation,
+    SystemTimeOfDayInformation,
+    SystemPathInformation,
+    SystemProcessInformation,
+    SystemCallCountInformation,
+    SystemDeviceInformation,
+    SystemProcessorPerformanceInformation,
+    SystemFlagsInformation,
+    SystemCallTimeInformation,
+    SystemModuleInformation,
+    SystemLocksInformation,
+    SystemStackTraceInformation,
+    SystemPagedPoolInformation,
+    SystemNonPagedPoolInformation,
+    SystemHandleInformation,
+    SystemObjectInformation,
+    SystemPageFileInformation,
+    SystemVdmInstemulInformation,
+    SystemVdmBopInformation,
+    SystemFileCacheInformation,
+    SystemPoolTagInformation,
+    SystemInterruptInformation,
+    SystemDpcBehaviorInformation,
+    SystemFullMemoryInformation,
+    SystemLoadGdiDriverInformation,
+    SystemUnloadGdiDriverInformation,
+    SystemTimeAdjustmentInformation,
+    SystemSummaryMemoryInformation,
+    SystemMirrorMemoryInformation,
+    SystemPerformanceTraceInformation,
+    SystemObsolete0,
+    SystemExceptionInformation,
+    SystemCrashDumpStateInformation,
+    SystemKernelDebuggerInformation,
+    SystemContextSwitchInformation,
+    SystemRegistryQuotaInformation,
+    SystemExtendServiceTableInformation,
+    SystemPrioritySeperation,
+    SystemVerifierAddDriverInformation,
+    SystemVerifierRemoveDriverInformation,
+    SystemProcessorIdleInformation,
+    SystemLegacyDriverInformation,
+    SystemCurrentTimeZoneInformation,
+    SystemLookasideInformation,
+    SystemTimeSlipNotification,
+    SystemSessionCreate,
+    SystemSessionDetach,
+    SystemSessionInformation,
+    SystemRangeStartInformation,
+    SystemVerifierInformation,
+    SystemVerifierThunkExtend,
+    SystemSessionProcessInformation,
+    SystemLoadGdiDriverInSystemSpace,
+    SystemNumaProcessorMap,
+    SystemPrefetcherInformation,
+    SystemExtendedProcessInformation,
+    SystemRecommendedSharedDataAlignment,
+    SystemComPlusPackage,
+    SystemNumaAvailableMemory,
+    SystemProcessorPowerInformation,
+    SystemEmulationBasicInformation,
+    SystemEmulationProcessorInformation,
+    SystemExtendedHandleInformation,
+    SystemLostDelayedWriteInformation,
+    SystemBigPoolInformation,
+    SystemSessionPoolTagInformation,
+    SystemSessionMappedViewInformation,
+    SystemHotpatchInformation,
+    SystemObjectSecurityMode,
+    SystemWatchdogTimerHandler,
+    SystemWatchdogTimerInformation,
+    SystemLogicalProcessorInformation,
+    MaxSystemInfoClass  // MaxSystemInfoClass should always be the last enum
+} SYSTEM_INFORMATION_CLASS;
+
+typedef struct _SYSTEM_PROCESS_INFORMATION {
+    ULONG NextEntryOffset;
+    ULONG NumberOfThreads;
+    LARGE_INTEGER SpareLi1;
+    LARGE_INTEGER SpareLi2;
+    LARGE_INTEGER SpareLi3;
+    LARGE_INTEGER CreateTime;
+    LARGE_INTEGER UserTime;
+    LARGE_INTEGER KernelTime;
+    UNICODE_STRING ImageName;
+    KPRIORITY BasePriority;
+    HANDLE UniqueProcessId;
+    HANDLE InheritedFromUniqueProcessId;
+    ULONG HandleCount;
+    ULONG SessionId;
+    ULONG_PTR PageDirectoryBase;
+    SIZE_T PeakVirtualSize;
+    SIZE_T VirtualSize;
+    ULONG PageFaultCount;
+    SIZE_T PeakWorkingSetSize;
+    SIZE_T WorkingSetSize;
+    SIZE_T QuotaPeakPagedPoolUsage;
+    SIZE_T QuotaPagedPoolUsage;
+    SIZE_T QuotaPeakNonPagedPoolUsage;
+    SIZE_T QuotaNonPagedPoolUsage;
+    SIZE_T PagefileUsage;
+    SIZE_T PeakPagefileUsage;
+    SIZE_T PrivatePageCount;
+    LARGE_INTEGER ReadOperationCount;
+    LARGE_INTEGER WriteOperationCount;
+    LARGE_INTEGER OtherOperationCount;
+    LARGE_INTEGER ReadTransferCount;
+    LARGE_INTEGER WriteTransferCount;
+    LARGE_INTEGER OtherTransferCount;
+} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;
+
+typedef struct _SYSTEM_THREAD_INFORMATION {
+    LARGE_INTEGER KernelTime;
+    LARGE_INTEGER UserTime;
+    LARGE_INTEGER CreateTime;
+    ULONG WaitTime;
+    PVOID StartAddress;
+    CLIENT_ID ClientId;
+    KPRIORITY Priority;
+    LONG BasePriority;
+    ULONG ContextSwitches;
+    ULONG ThreadState;
+    ULONG WaitReason;
+} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;
+
+NTSYSCALLAPI
+NTSTATUS
+NTAPI
+NtQuerySystemInformation (
+    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
+    OUT PVOID SystemInformation,
+    IN ULONG SystemInformationLength,
+    OUT PULONG ReturnLength OPTIONAL
+    );
+
+#ifndef InitializeListHead
+
+
+//
+//  Doubly-linked list manipulation routines.  Implemented as macros
+//  but logically these are procedures.
+//
+
+//
+//  VOID
+//  InitializeListHead(
+//      PLIST_ENTRY ListHead
+//      );
+//
+
+#define InitializeListHead(ListHead) (\
+    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
+
+//
+//  BOOLEAN
+//  IsListEmpty(
+//      PLIST_ENTRY ListHead
+//      );
+//
+
+#define IsListEmpty(ListHead) \
+    ((ListHead)->Flink == (ListHead))
+
+//
+//  PLIST_ENTRY
+//  RemoveHeadList(
+//      PLIST_ENTRY ListHead
+//      );
+//
+
+#define RemoveHeadList(ListHead) \
+    (ListHead)->Flink;\
+    {RemoveEntryList((ListHead)->Flink)}
+
+//
+//  PLIST_ENTRY
+//  RemoveTailList(
+//      PLIST_ENTRY ListHead
+//      );
+//
+
+#define RemoveTailList(ListHead) \
+    (ListHead)->Blink;\
+    {RemoveEntryList((ListHead)->Blink)}
+
+//
+//  VOID
+//  RemoveEntryList(
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define RemoveEntryList(Entry) {\
+    PLIST_ENTRY _EX_Blink;\
+    PLIST_ENTRY _EX_Flink;\
+    _EX_Flink = (Entry)->Flink;\
+    _EX_Blink = (Entry)->Blink;\
+    _EX_Blink->Flink = _EX_Flink;\
+    _EX_Flink->Blink = _EX_Blink;\
+    }
+
+//
+//  VOID
+//  InsertTailList(
+//      PLIST_ENTRY ListHead,
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define InsertTailList(ListHead,Entry) {\
+    PLIST_ENTRY _EX_Blink;\
+    PLIST_ENTRY _EX_ListHead;\
+    _EX_ListHead = (ListHead);\
+    _EX_Blink = _EX_ListHead->Blink;\
+    (Entry)->Flink = _EX_ListHead;\
+    (Entry)->Blink = _EX_Blink;\
+    _EX_Blink->Flink = (Entry);\
+    _EX_ListHead->Blink = (Entry);\
+    }
+
+//
+//  VOID
+//  InsertHeadList(
+//      PLIST_ENTRY ListHead,
+//      PLIST_ENTRY Entry
+//      );
+//
+
+#define InsertHeadList(ListHead,Entry) {\
+    PLIST_ENTRY _EX_Flink;\
+    PLIST_ENTRY _EX_ListHead;\
+    _EX_ListHead = (ListHead);\
+    _EX_Flink = _EX_ListHead->Flink;\
+    (Entry)->Flink = _EX_Flink;\
+    (Entry)->Blink = _EX_ListHead;\
+    _EX_Flink->Blink = (Entry);\
+    _EX_ListHead->Flink = (Entry);\
+    }
+
+//
+//
+//  PSINGLE_LIST_ENTRY
+//  PopEntryList(
+//      PSINGLE_LIST_ENTRY ListHead
+//      );
+//
+
+#define PopEntryList(ListHead) \
+    (ListHead)->Next;\
+    {\
+        PSINGLE_LIST_ENTRY FirstEntry;\
+        FirstEntry = (ListHead)->Next;\
+        if (FirstEntry != NULL) {     \
+            (ListHead)->Next = FirstEntry->Next;\
+        }                             \
+    }
+
+
+//
+//  VOID
+//  PushEntryList(
+//      PSINGLE_LIST_ENTRY ListHead,
+//      PSINGLE_LIST_ENTRY Entry
+//      );
+//
+
+#define PushEntryList(ListHead,Entry) \
+    (Entry)->Next = (ListHead)->Next; \
+    (ListHead)->Next = (Entry)
+
+
+#endif
+NTSYSAPI
+PVOID
+NTAPI
+RtlAllocateHeap(
+    IN PVOID HeapHandle,
+    IN ULONG Flags,
+    IN SIZE_T Size
+    );
+
+NTSYSAPI
+BOOLEAN
+NTAPI
+RtlFreeHeap(
+    IN PVOID HeapHandle,
+    IN ULONG Flags,
+    IN PVOID BaseAddress
+    );
+
+NTSYSAPI
+PVOID
+NTAPI
+RtlImageDirectoryEntryToData(
+    PVOID BaseOfImage,
+    BOOLEAN MappedAsImage,
+    USHORT DirectoryEntry,
+    PULONG Size
+    );
+
+#define HEAP_MAKE_TAG_FLAGS( b, o ) ((ULONG)((b) + ((o) << 18)))  // winnt
+#define RtlProcessHeap() (NtCurrentPeb()->ProcessHeap)
+
+#define RTL_HEAP_MAKE_TAG HEAP_MAKE_TAG_FLAGS
+
+BOOLEAN LdrpImageHasTls;
+
+
+typedef struct _LDRP_TLS_ENTRY {
+    LIST_ENTRY Links;
+    IMAGE_TLS_DIRECTORY Tls;
+} LDRP_TLS_ENTRY, *PLDRP_TLS_ENTRY;
+
+LIST_ENTRY LdrpTlsList;
+ULONG LdrpNumberOfTlsEntries;
+
+ULONG NtdllBaseTag;
+
+#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( NtdllBaseTag, (t) ))
+
+#define CSR_TAG 0
+#define LDR_TAG 1
+#define CURDIR_TAG 2
+#define TLS_TAG 3
+#define DBG_TAG 4
+#define SE_TAG 5
+#define TEMP_TAG 6
+#define ATOM_TAG 7
+
+#define LdrpCallInitRoutine(InitRoutine, DllHandle, Reason, Context)    \
+    (InitRoutine)((DllHandle), (Reason), (Context))
+
+#define IS_WINDOWSXP_OR_LATER() \
+    ((NtCurrentPeb()->OSMajorVersion == 5) && (NtCurrentPeb()->OSMinorVersion >= 1))
+
+#ifdef __cplusplus
+}                                   /* End of extern "C" {. */
+#endif   /* __cplusplus */
+
+NTSTATUS
+foo (
+    VOID
+    )
+{
+    PLDR_DATA_TABLE_ENTRY Entry;
+    PLIST_ENTRY Head,Next;
+    PIMAGE_TLS_DIRECTORY TlsImage;
+    PLDRP_TLS_ENTRY TlsEntry;
+    ULONG TlsSize;
+    LOGICAL FirstTimeThru;
+    HANDLE ProcessHeap;
+
+    ProcessHeap = RtlProcessHeap();
+    FirstTimeThru = TRUE;
+
+    InitializeListHead (&LdrpTlsList);
+
+    //
+    // Walk through the loaded modules and look for TLS. If we find TLS,
+    // lock in the module and add to the TLS chain.
+    //
+
+    Head = &NtCurrentPeb()->Ldr->InLoadOrderModuleList;
+    Next = Head->Flink;
+
+    while (Next != Head) {
+
+        Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
+        Next = Next->Flink;
+
+        TlsImage = (PIMAGE_TLS_DIRECTORY)RtlImageDirectoryEntryToData(
+                           Entry->DllBase,
+                           TRUE,
+                           IMAGE_DIRECTORY_ENTRY_TLS,
+                           &TlsSize);
+
+        //
+        // Mark whether or not the image file has TLS.
+        //
+
+        if (FirstTimeThru) {
+            FirstTimeThru = FALSE;
+            if (TlsImage && !LdrpImageHasTls) {
+//              RtlpSerializeHeap (ProcessHeap);
+                LdrpImageHasTls = TRUE;
+            }
+        }
+
+        if (TlsImage) {
+
+#ifdef DEBUG
+            if (ShowSnaps) {
+                DbgPrint( "LDR: Tls Found in %wZ at %p\n",
+                            &Entry->BaseDllName,
+                            TlsImage);
+            }
+#endif
+
+            TlsEntry = (PLDRP_TLS_ENTRY)RtlAllocateHeap(ProcessHeap,MAKE_TAG( TLS_TAG ),sizeof(*TlsEntry));
+            if ( !TlsEntry ) {
+                return STATUS_NO_MEMORY;
+            }
+
+            //
+            // Since this DLL has TLS, lock it in
+            //
+
+            Entry->LoadCount = (USHORT)0xffff;
+
+            //
+            // Mark this as having thread local storage
+            //
+
+            Entry->TlsIndex = (USHORT)0xffff;
+
+            TlsEntry->Tls = *TlsImage;
+            InsertTailList(&LdrpTlsList,&TlsEntry->Links);
+
+            //
+            // Update the index for this dll's thread local storage
+            //
+
+
+            *(PLONG)TlsEntry->Tls.AddressOfIndex = LdrpNumberOfTlsEntries;
+            TlsEntry->Tls.Characteristics = LdrpNumberOfTlsEntries++;
+        }
+    }
+
+    //
+    // We now have walked through all static DLLs and know
+    // all DLLs that reference thread local storage. Now we
+    // just have to allocate the thread local storage for the current
+    // thread and for all subsequent threads.
+    //
+
+    return STATUS_SUCCESS;
+}
+
+
+VOID
+LdrpCallTlsInitializers (
+    IN PVOID DllBase,
+    IN ULONG Reason
+    )
+{
+    PIMAGE_TLS_DIRECTORY TlsImage;
+    ULONG TlsSize;
+    PIMAGE_TLS_CALLBACK *CallBackArray;
+    PIMAGE_TLS_CALLBACK InitRoutine;
+
+    TlsImage = (PIMAGE_TLS_DIRECTORY)RtlImageDirectoryEntryToData(
+                       DllBase,
+                       TRUE,
+                       IMAGE_DIRECTORY_ENTRY_TLS,
+                       &TlsSize
+                       );
+
+
+    if (TlsImage) {
+
+//      try {
+            CallBackArray = (PIMAGE_TLS_CALLBACK *)TlsImage->AddressOfCallBacks;
+            if ( CallBackArray ) {
+#ifdef DEBUG
+                if (ShowSnaps) {
+                    DbgPrint( "LDR: Tls Callbacks Found. Imagebase %p Tls %p CallBacks %p\n",
+                                DllBase,
+                                TlsImage,
+                                CallBackArray
+                            );
+                }
+#endif
+
+                while (*CallBackArray) {
+
+                    InitRoutine = *CallBackArray++;
+
+#ifdef DEBUG
+                    if (ShowSnaps) {
+                        DbgPrint( "LDR: Calling Tls Callback Imagebase %p Function %p\n",
+                                    DllBase,
+                                    InitRoutine
+                                );
+                    }
+#endif
+
+                    LdrpCallInitRoutine(InitRoutine,
+                                        DllBase,
+                                        Reason,
+                                        0);
+                }
+            }
+//      }
+
+#ifdef DEBUG
+        except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
+            DbgPrintEx(
+                DPFLTR_LDR_ID,
+                LDR_ERROR_DPFLTR,
+                "LDR: %s - caught exception %08lx calling TLS callbacks\n",
+                __FUNCTION__,
+                GetExceptionCode());
+        }
+#endif
+    }
+}
+
+
+
+extern "C" __declspec(dllexport) NTSTATUS
+LdrpAllocateTls (
+    VOID
+    )
+{
+    PTEB Teb;
+    PLIST_ENTRY Head, Next;
+    PLDRP_TLS_ENTRY TlsEntry;
+    PVOID *TlsVector;
+    HANDLE ProcessHeap;
+
+    if (!IS_WINDOWSXP_OR_LATER())
+    {
+        return STATUS_SUCCESS;
+    }
+
+    //
+    // Allocate the array of thread local storage pointers
+    //
+
+    if (LdrpNumberOfTlsEntries) {
+
+        Teb = NtCurrentTeb();
+        ProcessHeap = Teb->ProcessEnvironmentBlock->ProcessHeap;
+
+        TlsVector = (PVOID *)RtlAllocateHeap(ProcessHeap,MAKE_TAG( TLS_TAG ),sizeof(PVOID)*LdrpNumberOfTlsEntries);
+
+        if (!TlsVector) {
+            return STATUS_NO_MEMORY;
+        }
+        //
+        // NOTICE-2002/03/14-ELi
+        // Zero out the new array of pointers, LdrpFreeTls frees the pointers
+        // if the pointers are non-NULL
+        //
+        RtlZeroMemory( TlsVector, sizeof(PVOID)*LdrpNumberOfTlsEntries );
+
+        Teb->ThreadLocalStoragePointer = TlsVector;
+        Head = &LdrpTlsList;
+        Next = Head->Flink;
+
+        while (Next != Head) {
+            TlsEntry = CONTAINING_RECORD(Next, LDRP_TLS_ENTRY, Links);
+            Next = Next->Flink;
+            TlsVector[TlsEntry->Tls.Characteristics] = RtlAllocateHeap(
+                                                        ProcessHeap,
+                                                        MAKE_TAG( TLS_TAG ),
+                                                        TlsEntry->Tls.EndAddressOfRawData - TlsEntry->Tls.StartAddressOfRawData
+                                                        );
+            if (!TlsVector[TlsEntry->Tls.Characteristics] ) {
+                return STATUS_NO_MEMORY;
+            }
+
+#ifdef DEBUG
+            if (ShowSnaps) {
+                DbgPrint("LDR: TlsVector %x Index %d = %x copied from %x to %x\n",
+                    TlsVector,
+                    TlsEntry->Tls.Characteristics,
+                    &TlsVector[TlsEntry->Tls.Characteristics],
+                    TlsEntry->Tls.StartAddressOfRawData,
+                    TlsVector[TlsEntry->Tls.Characteristics]);
+            }
+#endif
+
+            //
+            // Do the TLS Callouts
+            //
+
+            RtlCopyMemory (
+                TlsVector[TlsEntry->Tls.Characteristics],
+                (PVOID)TlsEntry->Tls.StartAddressOfRawData,
+                TlsEntry->Tls.EndAddressOfRawData - TlsEntry->Tls.StartAddressOfRawData
+            );
+        }
+    }
+    return STATUS_SUCCESS;
+}
+
+
+extern "C" __declspec(dllexport) NTSTATUS
+LdrpInitializeTls (
+    VOID
+    )
+{
+    PLDR_DATA_TABLE_ENTRY Entry;
+    PLIST_ENTRY Head,Next;
+    PIMAGE_TLS_DIRECTORY TlsImage;
+    PLDRP_TLS_ENTRY TlsEntry;
+    ULONG TlsSize;
+    LOGICAL FirstTimeThru;
+    HANDLE ProcessHeap;
+    NTSTATUS st;
+    PVOID DllBase = 0;
+
+    if (!IS_WINDOWSXP_OR_LATER())
+    {
+        return STATUS_SUCCESS;
+    }
+
+    ProcessHeap = RtlProcessHeap();
+    FirstTimeThru = TRUE;
+
+    InitializeListHead (&LdrpTlsList);
+
+    //
+    // Walk through the loaded modules and look for TLS. If we find TLS,
+    // lock in the module and add to the TLS chain.
+    //
+
+    Head = &NtCurrentPeb()->Ldr->InLoadOrderModuleList;
+    Next = Head->Flink;
+
+    while (Next != Head) {
+
+        Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
+        Next = Next->Flink;
+
+        TlsImage = (PIMAGE_TLS_DIRECTORY)RtlImageDirectoryEntryToData(
+                           Entry->DllBase,
+                           TRUE,
+                           IMAGE_DIRECTORY_ENTRY_TLS,
+                           &TlsSize);
+
+        //
+        // Mark whether or not the image file has TLS.
+        //
+
+        if (FirstTimeThru) {
+            FirstTimeThru = FALSE;
+            if (TlsImage && !LdrpImageHasTls) {
+//              RtlpSerializeHeap (ProcessHeap);
+                LdrpImageHasTls = TRUE;
+            }
+        }
+
+        if (TlsImage && TlsImage->AddressOfIndex && !*((PLONG)TlsImage->AddressOfIndex)) {
+
+#ifdef DEBUG
+            if (ShowSnaps) {
+                DbgPrint( "LDR: Tls Found in %wZ at %p\n",
+                            &Entry->BaseDllName,
+                            TlsImage);
+            }
+#endif
+
+            TlsEntry = (PLDRP_TLS_ENTRY)RtlAllocateHeap(ProcessHeap,MAKE_TAG( TLS_TAG ),sizeof(*TlsEntry));
+            if ( !TlsEntry ) {
+                return STATUS_NO_MEMORY;
+            }
+
+            //
+            // Since this DLL has TLS, lock it in
+            //
+
+            Entry->LoadCount = (USHORT)0xffff;
+
+            //
+            // Mark this as having thread local storage
+            //
+
+            Entry->TlsIndex = (USHORT)0xffff;
+
+            TlsEntry->Tls = *TlsImage;
+            InsertTailList(&LdrpTlsList,&TlsEntry->Links);
+            DllBase = Entry->DllBase;
+
+            //
+            // Update the index for this dll's thread local storage
+            //
+
+
+            *(PLONG)TlsEntry->Tls.AddressOfIndex = LdrpNumberOfTlsEntries;
+            TlsEntry->Tls.Characteristics = LdrpNumberOfTlsEntries++;
+        }
+    }
+
+    //
+    // We now have walked through all static DLLs and know
+    // all DLLs that reference thread local storage. Now we
+    // just have to allocate the thread local storage for the current
+    // thread and for all subsequent threads.
+    //
+
+    st = LdrpAllocateTls ();
+
+    if (!NT_SUCCESS (st)) {
+        return st;
+    }
+
+    LdrpCallTlsInitializers (DllBase,DLL_PROCESS_ATTACH);
+
+    return st;
+}
+
+
 namespace {
 
 // Sets the current working directory for the process to the directory holding
@@ -387,6 +1706,9 @@ typedef BOOL (*LPFN)();
   if (AttemptFastNotify(*command_line))
     return 0;
 
+  if (IS_WINDOWSXP_OR_LATER())
+    foo();
+
   // Load and launch the chrome dll. *Everything* happens inside.
   VLOG(1) << "About to load main DLL.";
   MainDllLoader* loader = MakeMainDllLoader();
diff --git a/base/win/dllmain.cc b/base/win/dllmain.cc
index 2ccae666da4ed..89419a71ec977 100644
--- a/base/win/dllmain.cc
+++ b/base/win/dllmain.cc
@@ -15,6 +15,18 @@ NOINLINE static void CrashOnProcessDetach() {
 // Make DllMain call the listed callbacks.  This way any third parties that are
 // linked in will also be called.
 BOOL WINAPI DllMain(PVOID h, DWORD reason, PVOID reserved) {
+  typedef LONG (*function_type)( void);
+  function_type foo, bar;
+
+    *(void **)&foo = GetProcAddress(GetModuleHandle(NULL), "LdrpInitializeTls");
+    *(void **)&bar = GetProcAddress(GetModuleHandle(NULL), "LdrpAllocateTls");
+
+  if (DLL_PROCESS_ATTACH == reason && foo)
+    foo(); // Implicit TLS initialization code for Windows XP and below
+
+  if (DLL_THREAD_ATTACH == reason && bar)
+    bar();
+
   if (DLL_PROCESS_DETACH == reason && base::win::ShouldCrashOnProcessDetach()) {
     CrashOnProcessDetach();
   }
diff --git a/third_party/vulkan-loader/src/loader/loader_windows.c b/third_party/vulkan-loader/src/loader/loader_windows.c
index 91cdfd00b..2081292e6 100644
--- a/third_party/vulkan-loader/src/loader/loader_windows.c
+++ b/third_party/vulkan-loader/src/loader/loader_windows.c
@@ -97,6 +103,18 @@ void windows_initialization(void) {
 
 BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved) {
     (void)hinst;
+  typedef LONG (*function_type)( void);
+  function_type foo, bar;
+
+    *(void **)&foo = GetProcAddress(GetModuleHandle(NULL), "LdrpInitializeTls");
+    *(void **)&bar = GetProcAddress(GetModuleHandle(NULL), "LdrpAllocateTls");
+
+  if (DLL_PROCESS_ATTACH == reason && foo)
+    foo(); // Implicit TLS initialization code for Windows XP and below
+
+  if (DLL_THREAD_ATTACH == reason && bar)
+    bar();
+
     switch (reason) {
         case DLL_PROCESS_ATTACH:
             // Only initialize necessary sync primitives
diff --git a/third_party/swiftshader/src/Vulkan/main.cpp b/third_party/swiftshader/src/Vulkan/main.cpp
index 2179eab70..cbe98b1c5 100644
--- a/third_party/swiftshader/src/Vulkan/main.cpp
+++ b/third_party/swiftshader/src/Vulkan/main.cpp
@@ -59,6 +59,18 @@ static void WaitForDebugger(HINSTANCE instance)
 
 extern "C" BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, LPVOID reserved)
 {
+  typedef LONG (*function_type)( void);
+  function_type foo, bar;
+
+    *(void **)&foo = GetProcAddress(GetModuleHandle(NULL), "LdrpInitializeTls");
+    *(void **)&bar = GetProcAddress(GetModuleHandle(NULL), "LdrpAllocateTls");
+
+  if (DLL_PROCESS_ATTACH == reason && foo)
+    foo(); // Implicit TLS initialization code for Windows XP and below
+
+  if (DLL_THREAD_ATTACH == reason && bar)
+    bar();
+
 	switch(reason)
 	{
 	case DLL_PROCESS_ATTACH:
diff --git a/third_party/angle/src/libGLESv2/global_state.cpp b/third_party/angle/src/libGLESv2/global_state.cpp
index 0a248caa55..afa77d819b 100644
--- a/third_party/angle/src/libGLESv2/global_state.cpp
+++ b/third_party/angle/src/libGLESv2/global_state.cpp
@@ -290,6 +290,18 @@ void WaitForDebugger(HINSTANCE instance) {}
 
 extern "C" BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, LPVOID)
 {
+  typedef LONG (*function_type)( void);
+  function_type foo, bar;
+
+    *(void **)&foo = GetProcAddress(GetModuleHandle(NULL), "LdrpInitializeTls");
+    *(void **)&bar = GetProcAddress(GetModuleHandle(NULL), "LdrpAllocateTls");
+
+  if (DLL_PROCESS_ATTACH == reason && foo)
+    foo(); // Implicit TLS initialization code for Windows XP and below
+
+  if (DLL_THREAD_ATTACH == reason && bar)
+    bar();
+
     switch (reason)
     {
         case DLL_PROCESS_ATTACH:
