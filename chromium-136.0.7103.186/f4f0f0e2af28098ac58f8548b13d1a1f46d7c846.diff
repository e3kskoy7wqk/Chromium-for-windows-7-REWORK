diff --git a/third_party/abseil-cpp/absl/synchronization/internal/win32_waiter.cc b/third_party/abseil-cpp/absl/synchronization/internal/win32_waiter.cc
index b6150b9b2bf13..7afeaef503249 100644
--- a/third_party/abseil-cpp/absl/synchronization/internal/win32_waiter.cc
+++ b/third_party/abseil-cpp/absl/synchronization/internal/win32_waiter.cc
@@ -282,6 +282,886 @@ void Waiter::Poke() {
 ABSL_NAMESPACE_BEGIN
 namespace synchronization_internal {
 
+#define NTKERNELAPI
+
+#ifndef FASTCALL
+#define FASTCALL
+#endif
+
+#define ASSERT(x)
+#define ASSERT_VALID(x)
+
+//
+// Push lock definitions
+//
+typedef struct _EX_PUSH_LOCK {
+
+#define EX_PUSH_LOCK_WAITING   0x1
+#define EX_PUSH_LOCK_EXCLUSIVE 0x2
+#define EX_PUSH_LOCK_SHARE_INC 0x4
+
+    union {
+        struct {
+            ULONG_PTR Waiting : 1;
+            ULONG_PTR Exclusive : 1;
+            ULONG_PTR Shared : sizeof (ULONG_PTR) * 8 - 2;
+        };
+        ULONG_PTR Value;
+        PVOID Ptr;
+    };
+} EX_PUSH_LOCK, *PEX_PUSH_LOCK;
+
+
+//
+// This is a block held on the local stack of the waiting threads.
+//
+
+typedef  struct _EX_PUSH_LOCK_WAIT_BLOCK *PEX_PUSH_LOCK_WAIT_BLOCK;
+
+typedef struct _EX_PUSH_LOCK_WAIT_BLOCK {
+    HANDLE WakeEvent;
+    PEX_PUSH_LOCK_WAIT_BLOCK Next;
+    PEX_PUSH_LOCK_WAIT_BLOCK Last;
+    PEX_PUSH_LOCK_WAIT_BLOCK Previous;
+    ULONG ShareCount;
+    BOOLEAN Exclusive;
+} EX_PUSH_LOCK_WAIT_BLOCK;
+
+VOID
+FORCEINLINE
+ExInitializePushLock (
+     IN PEX_PUSH_LOCK PushLock
+     )
+/*++
+
+Routine Description:
+
+    Initialize a push lock structure
+
+Arguments:
+
+    PushLock - Push lock to be initialized
+
+Return Value:
+
+    None
+
+--*/
+{
+    PushLock->Value = 0;
+}
+
+NTKERNELAPI
+VOID
+FASTCALL
+ExfAcquirePushLockExclusive (
+     IN PEX_PUSH_LOCK PushLock
+     )
+/*++
+
+Routine Description:
+
+    Acquire a push lock exclusively
+
+Arguments:
+
+    PushLock - Push lock to be acquired
+
+Return Value:
+
+    None
+
+--*/
+{
+    EX_PUSH_LOCK OldValue, NewValue;
+    EX_PUSH_LOCK_WAIT_BLOCK WaitBlock;
+
+    OldValue = *PushLock;
+    while (1) {
+        //
+        // If the lock is already held exclusively/shared or there are waiters then
+        // we need to wait.
+        //
+        if (OldValue.Value == 0) {
+            NewValue.Value = OldValue.Value + EX_PUSH_LOCK_EXCLUSIVE;
+            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                                              NewValue.Ptr,
+                                                              OldValue.Ptr);
+            if (NewValue.Ptr == OldValue.Ptr) {
+                break;
+            }
+        } else {
+            WaitBlock.WakeEvent = CreateEvent ( NULL, FALSE, FALSE, NULL );
+            WaitBlock.Exclusive = TRUE;
+            WaitBlock.Last = NULL;
+            WaitBlock.Previous = NULL;
+            //
+            // Move the sharecount to our wait block if need be.
+            //
+            if (OldValue.Waiting) {
+                WaitBlock.Next = (PEX_PUSH_LOCK_WAIT_BLOCK)
+                                     (OldValue.Value - EX_PUSH_LOCK_WAITING);
+                WaitBlock.ShareCount = 0;
+            } else {
+                WaitBlock.Next = NULL;
+                WaitBlock.ShareCount = (ULONG) OldValue.Shared;
+            }
+            NewValue.Ptr = ((PUCHAR) &WaitBlock) + EX_PUSH_LOCK_WAITING;
+            ASSERT ((NewValue.Value & EX_PUSH_LOCK_WAITING) != 0);
+            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                                              NewValue.Ptr,
+                                                              OldValue.Ptr);
+            if (NewValue.Ptr == OldValue.Ptr) {
+                WaitForSingleObject(WaitBlock.WakeEvent, INFINITE);
+                ASSERT ((WaitBlock.ShareCount == 0) && (WaitBlock.Next == NULL));
+                CloseHandle(WaitBlock.WakeEvent);
+                break;
+            }
+            CloseHandle(WaitBlock.WakeEvent);
+
+        }
+        OldValue = NewValue;
+    }
+}
+
+NTKERNELAPI
+VOID
+FASTCALL
+ExfReleasePushLock (
+     IN PEX_PUSH_LOCK PushLock
+     )
+/*++
+
+Routine Description:
+
+    Release a push lock that was acquired exclusively or shared
+
+Arguments:
+
+    PushLock - Push lock to be released
+
+Return Value:
+
+    None
+
+--*/
+{
+    EX_PUSH_LOCK OldValue, NewValue;
+    PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock, NextWaitBlock, ReleaseWaitList, Previous;
+    PEX_PUSH_LOCK_WAIT_BLOCK LastWaitBlock, FirstWaitBlock;
+    ULONG ShareCount;
+#if 0
+    KIRQL OldIrql;
+#endif
+
+    OldValue = *PushLock;
+    while (1) {
+        if (!OldValue.Waiting) {
+            //
+            // Either we hold the lock exclusive or shared but not both.
+            //
+            ASSERT (OldValue.Exclusive ^ (OldValue.Shared > 0));
+
+            //
+            // We must hold the lock exclusive or shared. We make the assuption that
+            // the exclusive bit is just below the share count here.
+            //
+            NewValue.Value = (OldValue.Value - EX_PUSH_LOCK_EXCLUSIVE) &
+                             ~EX_PUSH_LOCK_EXCLUSIVE;
+            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                                              NewValue.Ptr,
+                                                              OldValue.Ptr);
+            if (NewValue.Ptr == OldValue.Ptr) {
+                break;
+            }
+            //
+            // Either we gained a new waiter or another shared owner arrived or left
+            //
+            ASSERT (NewValue.Waiting || (NewValue.Shared > 0 && !NewValue.Exclusive));
+            OldValue = NewValue;
+        } else {
+            //
+            // There are waiters chained to the lock. We have to release the share count,
+            // last exclusive or last chain of shared waiters.
+            //
+            WaitBlock = (PEX_PUSH_LOCK_WAIT_BLOCK) 
+                           (OldValue.Value - EX_PUSH_LOCK_WAITING);
+
+            FirstWaitBlock = WaitBlock;
+            ReleaseWaitList = WaitBlock;
+            Previous = NULL;
+            LastWaitBlock = NULL;
+            ShareCount = 0;
+            do {
+
+                if (WaitBlock->Last != NULL) {
+                    LastWaitBlock = WaitBlock;
+                    WaitBlock = WaitBlock->Last;
+                    Previous = WaitBlock->Previous;
+                    ReleaseWaitList = WaitBlock;
+                    ASSERT (WaitBlock->Next == NULL);
+                    ASSERT (Previous != NULL);
+                    ShareCount = 0;
+                }
+
+                if (WaitBlock->Exclusive) {
+                    //
+                    // This is an exclusive waiter. If this was the first exclusive waited to a shared acquire
+                    // then it will have the saved share count. If we acquired the lock shared then the count
+                    // must contain a bias for this thread. Release that and if we are not the last shared
+                    // accessor then exit. A later shared release thread will wake the exclusive
+                    // waiter.
+                    //
+                    if (WaitBlock->ShareCount != 0) {
+                        if (InterlockedDecrement ((PLONG)&WaitBlock->ShareCount) != 0) {
+                            return;
+                        }
+                    }
+                    //
+                    // Reset count of share acquires waiting.
+                    //
+                    ShareCount = 0;
+                } else {
+                    //
+                    // This is a shared waiter. Record the number of these to update the head or the
+                    // previous exclusive waiter.
+                    //
+                    ShareCount++;
+                }
+                NextWaitBlock = WaitBlock->Next;
+                if (NextWaitBlock != NULL) {
+
+                    NextWaitBlock->Previous = WaitBlock;
+
+                    if (NextWaitBlock->Exclusive) {
+                        //
+                        // The next block is exclusive. This may be the entry to free.
+                        //
+                        Previous = WaitBlock;
+                        ReleaseWaitList = NextWaitBlock;
+                    } else {
+                        //
+                        // The next block is shared. If the chain start is exclusive then skip to this one
+                        // as the exclusive isn't the thread we will wake up.
+                        //
+                        if (ReleaseWaitList->Exclusive) {
+                            Previous = WaitBlock;
+                            ReleaseWaitList = NextWaitBlock;
+                        }
+                    }
+                }
+
+                WaitBlock = NextWaitBlock;
+            } while (WaitBlock != NULL);
+
+            //
+            // If our release chain is everything then we have to update the header
+            //
+            if (Previous == NULL) {
+                NewValue.Value = 0;
+                NewValue.Exclusive = ReleaseWaitList->Exclusive;
+                NewValue.Shared = ShareCount;
+                ASSERT (((ShareCount > 0) ^ (ReleaseWaitList->Exclusive)) && !NewValue.Waiting);
+
+                NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                                                  NewValue.Ptr,
+                                                                  OldValue.Ptr);
+                if (NewValue.Ptr != OldValue.Ptr) {
+                    //
+                    // We are releasing so we could have only gained another waiter
+                    //
+                    ASSERT (NewValue.Waiting);
+                    OldValue = NewValue;
+                    continue;
+                }
+            } else {
+
+                if (LastWaitBlock != NULL) {
+                    LastWaitBlock->Last = NULL;
+                }
+                //
+                // Truncate the chain at this position and save the share count for all the shared owners to
+                // decrement later.
+                //
+                Previous->Next = NULL;
+                ASSERT (Previous->ShareCount == 0);
+                Previous->ShareCount = ShareCount;
+
+                //
+                // Add a pointer to make future searches faster
+                //
+                if (Previous->Exclusive && FirstWaitBlock != Previous) {
+                    FirstWaitBlock->Last = Previous;
+                    ASSERT (Previous->Previous != NULL);
+                }
+                //
+                // We are either releasing multiple share accessors or a single exclusive
+                //
+                ASSERT ((ShareCount > 0) ^ ReleaseWaitList->Exclusive);
+            }
+
+#if 0
+            //
+            // If we are waking more than one thread then raise to DPC level to prevent us
+            // getting rescheduled part way through the operation
+            //
+
+            OldIrql = DISPATCH_LEVEL;
+            if (ShareCount > 1) {
+                KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);
+            }
+#endif
+
+            //
+            //
+            // Release the chain of threads we located.
+            //
+            do {
+                NextWaitBlock = ReleaseWaitList->Next;
+                //
+                // All the chain should have the same type (Exclusive/Shared).
+                //
+                ASSERT (NextWaitBlock == NULL || (ReleaseWaitList->Exclusive == NextWaitBlock->Exclusive));
+                ASSERT (!ReleaseWaitList->Exclusive || (ReleaseWaitList->ShareCount == 0));
+#if 0
+                KeSetEventBoostPriority (&ReleaseWaitList->WakeEvent, NULL);
+#endif
+                SetEvent(ReleaseWaitList->WakeEvent);
+                ReleaseWaitList = NextWaitBlock;
+            } while (ReleaseWaitList != NULL);
+
+#if 0
+            if (OldIrql != DISPATCH_LEVEL) {
+                KeLowerIrql (OldIrql);
+            }
+#endif
+
+
+            break;
+        }
+    }
+}
+
+VOID
+FORCEINLINE
+ExAcquirePushLockExclusive (
+     IN PEX_PUSH_LOCK PushLock
+     )
+/*++
+
+Routine Description:
+
+    Acquire a push lock exclusively
+
+Arguments:
+
+    PushLock - Push lock to be acquired
+
+Return Value:
+
+    None
+
+--*/
+{
+    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                           (PVOID)EX_PUSH_LOCK_EXCLUSIVE,
+                                           NULL) != NULL) {
+        ExfAcquirePushLockExclusive (PushLock);
+    }
+}
+
+VOID
+FORCEINLINE
+ExReleasePushLockExclusive (
+     IN PEX_PUSH_LOCK PushLock
+     )
+/*++
+
+Routine Description:
+
+    Release a push lock that was acquired exclusively
+
+Arguments:
+
+    PushLock - Push lock to be released
+
+Return Value:
+
+    None
+
+--*/
+{
+    ASSERT (PushLock->Value & (EX_PUSH_LOCK_WAITING|EX_PUSH_LOCK_EXCLUSIVE));
+
+    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
+                                           NULL,
+                                           (PVOID)EX_PUSH_LOCK_EXCLUSIVE) != (PVOID)EX_PUSH_LOCK_EXCLUSIVE) {
+        ExfReleasePushLock (PushLock);
+    }
+}
+
+typedef void *pthread_mutex_t;
+typedef void *pthread_cond_t;
+
+#define pthread_testcancel()
+#define LIFE_COND 0xC0BAB1FD
+#define DEAD_COND 0xC0DEADBF
+
+#define STATIC_COND_INITIALIZER(x)		((pthread_cond_t)(x) == ((pthread_cond_t)PTHREAD_COND_INITIALIZER))
+
+typedef struct cond_t cond_t;
+struct cond_t
+{
+    unsigned int valid;   
+    int busy;
+    LONG waiters_count_; /* Number of waiting threads.  */
+    LONG waiters_count_unblock_; /* Number of waiting threads whitch can be unblocked.  */
+    LONG waiters_count_gone_; /* Number of waiters which are gone.  */
+    CRITICAL_SECTION waiters_count_lock_; /* Serialize access to <waiters_count_>.  */
+    CRITICAL_SECTION waiters_q_lock_; /* Serialize access to sema_q.  */
+    LONG value_q;
+    CRITICAL_SECTION waiters_b_lock_; /* Serialize access to sema_b.  */
+    LONG value_b;
+    HANDLE sema_q; /* Semaphore used to queue up threads waiting for the condition to
+                 become signaled.  */
+    HANDLE sema_b; /* Semaphore used to queue up threads waiting for the condition which
+                 became signaled.  */
+};
+
+#define __pthread_shallcancel() (0)
+
+static int do_sema_b_wait (HANDLE sema, int nointerrupt, DWORD timeout,CRITICAL_SECTION *cs, LONG *val);
+static int do_sema_b_release(HANDLE sema, LONG count,CRITICAL_SECTION *cs, LONG *val);
+static void cleanup_wait(void *arg);
+
+typedef struct sCondWaitHelper {
+    cond_t *c;
+    pthread_mutex_t *external_mutex;
+    int *r;
+} sCondWaitHelper;
+
+static int do_sema_b_wait_intern (HANDLE sema, int nointerrupt, DWORD timeout);
+
+static int
+pthread_cond_init (pthread_cond_t *c, const void *a)
+{
+  cond_t *_c;
+  int r = 0;
+
+  if (!c)
+    return EINVAL;
+#if 0
+  if (a && *a == PTHREAD_PROCESS_SHARED)
+    return ENOSYS;
+#endif
+
+  if ( !(_c = (cond_t *)HeapAlloc(GetProcessHeap(), 0, sizeof(*_c))) ) {
+      return ENOMEM; 
+  }
+  _c->valid  = DEAD_COND;
+  _c->busy = 0;
+  _c->waiters_count_ = 0;
+  _c->waiters_count_gone_ = 0;
+  _c->waiters_count_unblock_ = 0;
+
+  _c->sema_q = CreateSemaphore (NULL,       /* no security */
+      0,          /* initially 0 */
+      0x7fffffff, /* max count */
+      NULL);      /* unnamed  */
+  _c->sema_b =  CreateSemaphore (NULL,       /* no security */
+      0,          /* initially 0 */
+      0x7fffffff, /* max count */
+      NULL);  
+  if (_c->sema_q == NULL || _c->sema_b == NULL) {
+      if (_c->sema_q != NULL)
+        CloseHandle (_c->sema_q);
+      if (_c->sema_b != NULL)
+        CloseHandle (_c->sema_b);
+      HeapFree(GetProcessHeap(), 0, _c);
+      r = EAGAIN;
+  } else {
+      InitializeCriticalSection(&_c->waiters_count_lock_);
+      InitializeCriticalSection(&_c->waiters_b_lock_);
+      InitializeCriticalSection(&_c->waiters_q_lock_);
+      _c->value_q = 0;
+      _c->value_b = 1;
+  }
+  if (!r)
+    {
+      _c->valid = LIFE_COND;
+      *c = (pthread_cond_t)_c;
+    }
+  else
+    *c = (pthread_cond_t)NULL;
+  return r;
+}
+
+static pthread_mutex_t cond_locked = 0;
+
+static int
+cond_static_init (pthread_cond_t *c)
+{
+  int r = 0;
+  
+  ExAcquirePushLockExclusive((PEX_PUSH_LOCK)&cond_locked);
+  if (c == NULL)
+    r = EINVAL;
+  else if (*c == 0)
+    r = pthread_cond_init (c, NULL);
+  else
+    /* We assume someone was faster ... */
+    r = 0;
+  ExReleasePushLockExclusive((PEX_PUSH_LOCK)&cond_locked);
+  return r;
+}
+
+static int
+pthread_cond_signal (pthread_cond_t *c)
+{
+  cond_t *_c;
+  int r;
+
+  if (!c || 0)
+    return EINVAL;
+  _c = (cond_t *)*c;
+  if (_c == (cond_t *)0)
+    return 0;
+  else if (_c->valid != (unsigned int)LIFE_COND)
+    return EINVAL;
+
+  EnterCriticalSection (&_c->waiters_count_lock_);
+  /* If there aren't any waiters, then this is a no-op.   */
+  if (_c->waiters_count_unblock_ != 0)
+    {
+      if (_c->waiters_count_ == 0)
+      {
+        LeaveCriticalSection (&_c->waiters_count_lock_);
+        /* pthread_testcancel(); */
+        return 0;
+      }
+      _c->waiters_count_ -= 1;
+      _c->waiters_count_unblock_ += 1;
+    }
+  else if (_c->waiters_count_ > _c->waiters_count_gone_)
+    {
+      r = do_sema_b_wait (_c->sema_b, 1, INFINITE,&_c->waiters_b_lock_,&_c->value_b);
+      if (r != 0)
+      {
+        LeaveCriticalSection (&_c->waiters_count_lock_);
+        /* pthread_testcancel(); */
+        return r;
+      }
+      if (_c->waiters_count_gone_ != 0)
+      {
+        _c->waiters_count_ -= _c->waiters_count_gone_;
+        _c->waiters_count_gone_ = 0;
+      }
+      _c->waiters_count_ -= 1;
+      _c->waiters_count_unblock_ = 1;
+    }
+  else
+    {
+      LeaveCriticalSection (&_c->waiters_count_lock_);
+      /* pthread_testcancel(); */
+      return 0;
+    }
+  LeaveCriticalSection (&_c->waiters_count_lock_);
+  r = do_sema_b_release(_c->sema_q, 1,&_c->waiters_q_lock_,&_c->value_q);
+  /* pthread_testcancel(); */
+  return r;
+}
+
+static int
+pthread_cond_timedwait_impl (pthread_cond_t *c, pthread_mutex_t *external_mutex, DWORD t, int rel)
+{
+  sCondWaitHelper ch;
+  DWORD dwr;
+  int r;
+  cond_t *_c;
+
+  /* pthread_testcancel(); */
+
+  if (!c || 0)
+    return EINVAL;
+  _c = (cond_t *)*c;
+  if (_c == (cond_t *)0)
+  {
+    r = cond_static_init(c);
+    if (r && r != EBUSY)
+      return r;
+    _c = (cond_t *) *c;
+  } else if ((_c)->valid != (unsigned int)LIFE_COND)
+    return EINVAL;
+
+#if 0
+  if (rel == 0)
+  {
+    dwr = dwMilliSecs(_pthread_rel_time_in_ms(t));
+  }
+  else
+  {
+    dwr = dwMilliSecs(_pthread_time_in_ms_from_timespec(t));
+  }
+#endif
+    dwr = t;
+
+tryagain:
+  r = do_sema_b_wait (_c->sema_b, 0, INFINITE,&_c->waiters_b_lock_,&_c->value_b);
+  if (r != 0)
+    return r;
+
+  if (!TryEnterCriticalSection (&_c->waiters_count_lock_))
+  {
+    r = do_sema_b_release (_c->sema_b, 1,&_c->waiters_b_lock_,&_c->value_b);
+    if (r != 0)
+      return r;
+    Sleep(0);
+    goto tryagain;
+  }
+
+  _c->waiters_count_++;
+  LeaveCriticalSection(&_c->waiters_count_lock_);
+  r = do_sema_b_release (_c->sema_b, 1,&_c->waiters_b_lock_,&_c->value_b);
+  if (r != 0)
+    return r;
+
+  ch.c = _c;
+  ch.r = &r;
+  ch.external_mutex = external_mutex;
+  {
+#if 0
+    pthread_cleanup_push(cleanup_wait, (void *) &ch);
+#endif
+
+    r = 0,ExReleasePushLockExclusive((PEX_PUSH_LOCK)external_mutex);
+    if (!r)
+      r = do_sema_b_wait (_c->sema_q, 0, dwr,&_c->waiters_q_lock_,&_c->value_q);
+
+#if 0
+    pthread_cleanup_pop(1);
+#endif
+    cleanup_wait( (void *) &ch);
+  }
+  return r;
+}
+
+static int
+pthread_cond_timedwait(pthread_cond_t *c, pthread_mutex_t *m, DWORD t)
+{
+  return pthread_cond_timedwait_impl(c, m, t, 0);
+}
+
+static void
+cleanup_wait (void *arg)
+{
+  int n, r;
+  sCondWaitHelper *ch = (sCondWaitHelper *) arg;
+  cond_t *_c;
+
+  _c = ch->c;
+  EnterCriticalSection (&_c->waiters_count_lock_);
+  n = _c->waiters_count_unblock_;
+  if (n != 0)
+    _c->waiters_count_unblock_ -= 1;
+  else if ((INT_MAX/2) - 1 == _c->waiters_count_gone_)
+  {
+    _c->waiters_count_gone_ += 1;
+    r = do_sema_b_wait (_c->sema_b, 1, INFINITE,&_c->waiters_b_lock_,&_c->value_b);
+    if (r != 0)
+    {
+      LeaveCriticalSection(&_c->waiters_count_lock_);
+      ch->r[0] = r;
+      return;
+    }
+    _c->waiters_count_ -= _c->waiters_count_gone_;
+    r = do_sema_b_release (_c->sema_b, 1,&_c->waiters_b_lock_,&_c->value_b);
+    if (r != 0)
+    {
+      LeaveCriticalSection(&_c->waiters_count_lock_);
+      ch->r[0] = r;
+      return;
+    }
+    _c->waiters_count_gone_ = 0;
+  }
+  else
+    _c->waiters_count_gone_ += 1;
+  LeaveCriticalSection (&_c->waiters_count_lock_);
+
+  if (n == 1)
+  {
+    r = do_sema_b_release (_c->sema_b, 1,&_c->waiters_b_lock_,&_c->value_b);
+    if (r != 0)
+    {
+      ch->r[0] = r;
+      return;
+    }
+  }
+  r = 0,ExAcquirePushLockExclusive((PEX_PUSH_LOCK)ch->external_mutex);
+  if (r != 0)
+    ch->r[0] = r;
+}
+
+static int
+do_sema_b_wait (HANDLE sema, int nointerrupt, DWORD timeout,CRITICAL_SECTION *cs, LONG *val)
+{
+  int r;
+  LONG v;
+  EnterCriticalSection(cs);
+  InterlockedDecrement(val);
+  v = val[0];
+  LeaveCriticalSection(cs);
+  if (v >= 0)
+    return 0;
+  r = do_sema_b_wait_intern (sema, nointerrupt, timeout);
+  EnterCriticalSection(cs);
+  if (r != 0)
+    InterlockedIncrement(val);
+  LeaveCriticalSection(cs);
+  return r;
+}
+
+static int
+do_sema_b_wait_intern (HANDLE sema, int nointerrupt, DWORD timeout)
+{
+  HANDLE arr[2];
+  DWORD maxH = 1;
+  int r = 0;
+  DWORD res, dt;
+  if (nointerrupt == 1)
+  {
+    res = WaitForSingleObject(sema, timeout);
+    switch (res) {
+    case WAIT_TIMEOUT:
+        r = ETIMEDOUT;
+        break;
+    case WAIT_ABANDONED:
+        r = EPERM;
+        break;
+    case WAIT_OBJECT_0:
+        break;
+    default:
+        /*We can only return EINVAL though it might not be posix compliant  */
+        r = EINVAL;
+    }
+    if (r != 0 && r != EINVAL && WaitForSingleObject(sema, 0) == WAIT_OBJECT_0)
+      r = 0;
+    return r;
+  }
+  arr[0] = sema;
+  arr[1] = (HANDLE) NULL;
+  if (arr[1] != NULL) maxH += 1;
+  if (maxH == 2)
+  {
+redo:
+      res = WaitForMultipleObjects(maxH, arr, 0, timeout);
+      switch (res) {
+      case WAIT_TIMEOUT:
+          r = ETIMEDOUT;
+          break;
+      case (WAIT_OBJECT_0 + 1):
+          ResetEvent(arr[1]);
+          if (nointerrupt != 2)
+            {
+            pthread_testcancel();
+            return EINVAL;
+            }
+          pthread_testcancel ();
+          goto redo;
+      case WAIT_ABANDONED:
+          r = EPERM;
+          break;
+      case WAIT_OBJECT_0:
+          r = 0;
+          break;
+      default:
+          /*We can only return EINVAL though it might not be posix compliant  */
+          r = EINVAL;
+      }
+      if (r != 0 && r != EINVAL && WaitForSingleObject(arr[0], 0) == WAIT_OBJECT_0)
+        r = 0;
+      if (r != 0 && nointerrupt != 2 && __pthread_shallcancel ())
+        return EINVAL;
+      return r;
+  }
+  if (timeout == INFINITE)
+  {
+    do {
+      res = WaitForSingleObject(sema, 40);
+      switch (res) {
+      case WAIT_TIMEOUT:
+          r = ETIMEDOUT;
+          break;
+      case WAIT_ABANDONED:
+          r = EPERM;
+          break;
+      case WAIT_OBJECT_0:
+          r = 0;
+          break;
+      default:
+          /*We can only return EINVAL though it might not be posix compliant  */
+          r = EINVAL;
+      }
+      if (r != 0 && __pthread_shallcancel ())
+      {
+        if (nointerrupt != 2)
+          pthread_testcancel();
+        return EINVAL;
+      }
+    } while (r == ETIMEDOUT);
+    if (r != 0 && r != EINVAL && WaitForSingleObject(sema, 0) == WAIT_OBJECT_0)
+      r = 0;
+    return r;
+  }
+  dt = 20;
+  do {
+    if (dt > timeout) dt = timeout;
+    res = WaitForSingleObject(sema, dt);
+    switch (res) {
+    case WAIT_TIMEOUT:
+        r = ETIMEDOUT;
+        break;
+    case WAIT_ABANDONED:
+        r = EPERM;
+        break;
+    case WAIT_OBJECT_0:
+        r = 0;
+        break;
+    default:
+        /*We can only return EINVAL though it might not be posix compliant  */
+        r = EINVAL;
+    }
+    timeout -= dt;
+    if (timeout != 0 && r != 0 && __pthread_shallcancel ())
+      return EINVAL;
+  } while (r == ETIMEDOUT && timeout != 0);
+  if (r != 0 && r == ETIMEDOUT && WaitForSingleObject(sema, 0) == WAIT_OBJECT_0)
+    r = 0;
+  if (r != 0 && nointerrupt != 2)
+    pthread_testcancel();
+  return r;
+}
+
+static int
+do_sema_b_release(HANDLE sema, LONG count,CRITICAL_SECTION *cs, LONG *val)
+{
+  int wc;
+  EnterCriticalSection(cs);
+  if (((long long) val[0] + (long long) count) > (long long) 0x7fffffffLL)
+  {
+    LeaveCriticalSection(cs);
+    return ERANGE;
+  }
+  wc = -val[0];
+  InterlockedExchangeAdd(val, count);
+  if (wc <= 0 || ReleaseSemaphore(sema, (wc < count ? wc : count), NULL))
+  {
+    LeaveCriticalSection(cs);
+    return 0;
+  }
+  InterlockedExchangeAdd(val, -count);
+  LeaveCriticalSection(cs);
+  return EINVAL;  
+}
 class Win32Waiter::WinHelper {
  public:
   static SRWLOCK *GetLock(Win32Waiter *w) {
@@ -320,14 +1200,14 @@ class Waiter::WinHelper {
 class LockHolder {
  public:
   explicit LockHolder(SRWLOCK* mu) : mu_(mu) {
-    AcquireSRWLockExclusive(mu_);
+    ExAcquirePushLockExclusive((PEX_PUSH_LOCK)mu_);
   }
 
   LockHolder(const LockHolder&) = delete;
   LockHolder& operator=(const LockHolder&) = delete;
 
   ~LockHolder() {
-    ReleaseSRWLockExclusive(mu_);
+    ExReleasePushLockExclusive((PEX_PUSH_LOCK)mu_);
   }
 
  private:
@@ -337,8 +1217,8 @@ class LockHolder {
 Win32Waiter::Win32Waiter() {
   auto *mu = ::new (static_cast<void *>(&mu_storage_)) SRWLOCK;
   auto *cv = ::new (static_cast<void *>(&cv_storage_)) CONDITION_VARIABLE;
-  InitializeSRWLock(mu);
-  InitializeConditionVariable(cv);
+  ExInitializePushLock((PEX_PUSH_LOCK)mu);
+  pthread_cond_init((pthread_cond_t *)cv, 0);
   waiter_count_ = 0;
   wakeup_count_ = 0;
 }
@@ -357,18 +1237,14 @@ bool Waiter::Wait(KernelTimeout t) {
   while (wakeup_count_ == 0) {
     if (!first_pass) MaybeBecomeIdle();
     // No wakeups available, time to wait.
-    if (!SleepConditionVariableSRW(cv, mu, t.InMillisecondsFromNow(), 0)) {
-      // GetLastError() returns a Win32 DWORD, but we assign to
-      // unsigned long to simplify the ABSL_RAW_LOG case below.  The uniform
-      // initialization guarantees this is not a narrowing conversion.
-      const unsigned long err{GetLastError()};  // NOLINT(runtime/int)
-      if (err == ERROR_TIMEOUT) {
+      const int err = pthread_cond_timedwait((pthread_cond_t *)cv, (pthread_mutex_t *)mu, t.InMillisecondsFromNow());
+      if (err == ETIMEDOUT) {
         --waiter_count_;
         return false;
-      } else {
-        ABSL_RAW_LOG(FATAL, "SleepConditionVariableSRW failed: %lu", err);
       }
-    }
+      if (err != 0) {
+        ABSL_RAW_LOG(FATAL, "pthread_cond_timedwait failed: %d", err);
+      }
     first_pass = false;
   }
   // Consume a wakeup and we're done.
@@ -390,7 +1266,10 @@ void Waiter::Poke() {
 
 void Win32Waiter::InternalCondVarPoke() {
   if (waiter_count_ != 0) {
-    WakeConditionVariable(WinHelper::GetCond(this));
+    const int err = pthread_cond_signal((pthread_cond_t *)WinHelper::GetCond(this));
+    if (ABSL_PREDICT_FALSE(err != 0)) {
+      ABSL_RAW_LOG(FATAL, "pthread_cond_signal failed: %d", err);
+    }
   }
 }
 
