diff --git a/base/BUILD.gn b/base/BUILD.gn
index 0f0285d500b36..8b3fecbe722de 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -122,12 +122,9 @@ if (is_win) {
   # ldflags in GN aren't automatically inherited.
   config("base_win_linker_flags") {
     ldflags = [
-      # Linking with shcore.lib causes the shcore api forwarder dll to load.
-      "/DELAYLOAD:api-ms-win-shcore-scaling-l1-1-1.dll",
       "/DELAYLOAD:cfgmgr32.dll",
       "/DELAYLOAD:powrprof.dll",
       "/DELAYLOAD:setupapi.dll",
-      "/DELAYLOAD:shcore.dll",
     ]
   }
 }
@@ -2112,7 +2109,6 @@ component("base") {
       "powrprof.lib",
       "propsys.lib",
       "setupapi.lib",
-      "shcore.lib",
       "userenv.lib",
       "wbemuuid.lib",
       "winmm.lib",
diff --git a/base/win/win_util.cc b/base/win/win_util.cc
index 29e283facb6cc..13d8a980ea11b 100644
--- a/base/win/win_util.cc
+++ b/base/win/win_util.cc
@@ -101,6 +101,34 @@ POWER_PLATFORM_ROLE GetPlatformRole() {
   return PowerDeterminePlatformRoleEx(POWER_PLATFORM_ROLE_V2);
 }
 
+// Because we used to support versions earlier than 8.1, we dynamically load
+// this function from user32.dll, so it won't fail to load in runtime.
+// TODO(https://crbug.com/1408307): Call SetProcessDpiAwareness directly.
+bool SetProcessDpiAwarenessWrapper(PROCESS_DPI_AWARENESS value) {
+  if (!IsUser32AndGdi32Available())
+    return false;
+
+  static const auto set_process_dpi_awareness_func =
+      reinterpret_cast<decltype(&::SetProcessDpiAwareness)>(
+          GetUser32FunctionPointer("SetProcessDpiAwarenessInternal"));
+  if (set_process_dpi_awareness_func) {
+    HRESULT hr = set_process_dpi_awareness_func(value);
+    if (SUCCEEDED(hr))
+      return true;
+    DLOG_IF(ERROR, hr == E_ACCESSDENIED)
+        << "Access denied error from SetProcessDpiAwarenessInternal. "
+           "Function called twice, or manifest was used.";
+    NOTREACHED()
+        << "SetProcessDpiAwarenessInternal failed with unexpected error: "
+        << hr;
+    return false;
+  }
+
+  NOTREACHED() << "SetProcessDpiAwarenessInternal "
+                  "should be available on all platforms >= Windows 8.1";
+  return false;
+}
+
 // Enable V2 per-monitor high-DPI support for the process. This will cause
 // Windows to scale dialogs, comctl32 controls, context menus, and non-client
 // area owned by this process on a per-monitor basis. If per-monitor V2 is not
@@ -687,6 +715,31 @@ void DisableFlicks(HWND hwnd) {
                                      TABLET_DISABLE_FLICKFALLBACKKEYS));
 }
 
+bool IsProcessPerMonitorDpiAware() {
+  enum class PerMonitorDpiAware {
+    UNKNOWN = 0,
+    PER_MONITOR_DPI_UNAWARE,
+    PER_MONITOR_DPI_AWARE,
+  };
+  static PerMonitorDpiAware per_monitor_dpi_aware = PerMonitorDpiAware::UNKNOWN;
+  if (per_monitor_dpi_aware == PerMonitorDpiAware::UNKNOWN) {
+    per_monitor_dpi_aware = PerMonitorDpiAware::PER_MONITOR_DPI_UNAWARE;
+    HMODULE shcore_dll = ::LoadLibrary(L"shcore.dll");
+    if (shcore_dll) {
+      auto get_process_dpi_awareness_func =
+          reinterpret_cast<decltype(::GetProcessDpiAwareness)*>(
+              ::GetProcAddress(shcore_dll, "GetProcessDpiAwareness"));
+      if (get_process_dpi_awareness_func) {
+        PROCESS_DPI_AWARENESS awareness;
+        if (SUCCEEDED(get_process_dpi_awareness_func(nullptr, &awareness)) &&
+            awareness == PROCESS_PER_MONITOR_DPI_AWARE)
+          per_monitor_dpi_aware = PerMonitorDpiAware::PER_MONITOR_DPI_AWARE;
+      }
+    }
+  }
+  return per_monitor_dpi_aware == PerMonitorDpiAware::PER_MONITOR_DPI_AWARE;
+}
+
 void EnableHighDPISupport() {
   if (!IsUser32AndGdi32Available()) {
     return;
@@ -697,7 +750,7 @@ void EnableHighDPISupport() {
 
   // Fall back to per-monitor DPI for older versions of Win10.
   PROCESS_DPI_AWARENESS process_dpi_awareness = PROCESS_PER_MONITOR_DPI_AWARE;
-  if (!::SetProcessDpiAwareness(process_dpi_awareness)) {
+  if (!SetProcessDpiAwarenessWrapper(process_dpi_awareness)) {
     // For windows versions where SetProcessDpiAwareness fails, try its
     // predecessor.
     BOOL result = ::SetProcessDPIAware();
diff --git a/base/win/win_util.h b/base/win/win_util.h
index c50b3c2735c37..7f3dc6048eb91 100644
--- a/base/win/win_util.h
+++ b/base/win/win_util.h
@@ -197,6 +197,9 @@ BASE_EXPORT bool GetLoadedModulesSnapshot(HANDLE process,
 BASE_EXPORT void EnableFlicks(HWND hwnd);
 BASE_EXPORT void DisableFlicks(HWND hwnd);
 
+// Returns true if the process is per monitor DPI aware.
+BASE_EXPORT bool IsProcessPerMonitorDpiAware();
+
 // Enable high-DPI support for the current process.
 BASE_EXPORT void EnableHighDPISupport();
 
diff --git a/ui/display/BUILD.gn b/ui/display/BUILD.gn
index 0f86f36cdbda7..aadf9f2a52fd6 100644
--- a/ui/display/BUILD.gn
+++ b/ui/display/BUILD.gn
@@ -112,8 +112,6 @@ component("display") {
       "//components/headless/screen_info",
       "//ui/gfx/mojom:dxgi_info",
     ]
-    libs = [ "shcore.lib" ]
-    ldflags = [ "/DELAYLOAD:shcore.dll" ]
   }
 
   if (use_aura) {
diff --git a/ui/display/win/screen_win.cc b/ui/display/win/screen_win.cc
index 95ce3f5118cdc..6f473e7cdaa2e 100644
--- a/ui/display/win/screen_win.cc
+++ b/ui/display/win/screen_win.cc
@@ -44,11 +44,20 @@ ScreenWin* g_instance = nullptr;
 
 // Gets the DPI for a particular monitor.
 std::optional<int> GetPerMonitorDPI(HMONITOR monitor) {
+  if (!base::win::IsProcessPerMonitorDpiAware())
+    return std::nullopt;
+
+  static auto get_dpi_for_monitor_func = []() {
+    const HMODULE shcore_dll = ::LoadLibrary(L"shcore.dll");
+    return reinterpret_cast<decltype(&::GetDpiForMonitor)>(
+        shcore_dll ? ::GetProcAddress(shcore_dll, "GetDpiForMonitor")
+                   : nullptr);
+  }();
   UINT dpi_x, dpi_y;
-  if (!SUCCEEDED(
-          ::GetDpiForMonitor(monitor, MDT_EFFECTIVE_DPI, &dpi_x, &dpi_y))) {
+  if (!get_dpi_for_monitor_func ||
+      !SUCCEEDED(
+          get_dpi_for_monitor_func(monitor, MDT_EFFECTIVE_DPI, &dpi_x, &dpi_y)))
     return std::nullopt;
-  }
 
   DCHECK_EQ(dpi_x, dpi_y);
   return static_cast<int>(dpi_x);
@@ -749,13 +758,11 @@ absl::optional<bool> ScreenWin::IsWindowOnCurrentVirtualDesktop(
   NOTREACHED();
 }
 
-ScreenWin::ScreenWin(bool initialize_from_system)
-    : per_process_dpi_awareness_disabled_for_testing_(!initialize_from_system) {
+ScreenWin::ScreenWin(bool initialize) {
   DCHECK(!g_instance);
   g_instance = this;
-  if (initialize_from_system) {
+  if (initialize)
     Initialize();
-  }
 }
 
 gfx::Point ScreenWin::GetCursorScreenPoint() {
@@ -1006,7 +1013,7 @@ ScreenWinDisplay ScreenWin::GetScreenWinDisplayVia(Getter getter,
 
 int ScreenWin::GetSystemMetricsForScaleFactor(float scale_factor,
                                               int metric) const {
-  if (!PerProcessDPIAwarenessDisabledForTesting()) {
+  if (base::win::IsProcessPerMonitorDpiAware()) {
     static const auto get_system_metrics_for_dpi =
         reinterpret_cast<decltype(&::GetSystemMetricsForDpi)>(
             base::win::GetUser32FunctionPointer("GetSystemMetricsForDpi"));
@@ -1016,7 +1023,7 @@ int ScreenWin::GetSystemMetricsForScaleFactor(float scale_factor,
     }
   }
 
-  // Versions < WIN10_RS1 don't support GetSystemMetricsForDpi, but do support
+  // Windows 8.1 doesn't support GetSystemMetricsForDpi(), yet does support
   // per-process dpi awareness.
   return base::ClampRound(GetSystemMetrics(metric) * scale_factor /
                           GetPrimaryDisplay().device_scale_factor());
@@ -1047,9 +1054,5 @@ void ScreenWin::OnUwpTextScaleFactorCleanup(UwpTextScaleFactor* source) {
   UwpTextScaleFactor::Observer::OnUwpTextScaleFactorCleanup(source);
 }
 
-bool ScreenWin::PerProcessDPIAwarenessDisabledForTesting() const {
-  return per_process_dpi_awareness_disabled_for_testing_;
-}
-
 }  // namespace win
 }  // namespace display
diff --git a/ui/display/win/screen_win.h b/ui/display/win/screen_win.h
index 55fd098791ccc..b8746f562430e 100644
--- a/ui/display/win/screen_win.h
+++ b/ui/display/win/screen_win.h
@@ -178,11 +178,7 @@ class DISPLAY_EXPORT ScreenWin : public Screen,
   FRIEND_TEST_ALL_PREFIXES(ScreenWinTestSingleDisplay1x,
                            DisconnectPrimaryDisplay);
 
-  // `initialize_from_system` is true if the ScreenWin should be initialized
-  // from the Windows desktop environment, e.g., the monitor information and
-  // configuration. It is false in unit tests, true in Chrome and browser
-  // tests.
-  ScreenWin(bool initialize_from_system);
+  ScreenWin(bool initialize);
 
   // Screen:
   gfx::Point GetCursorScreenPoint() override;
@@ -268,12 +264,6 @@ class DISPLAY_EXPORT ScreenWin : public Screen,
   void OnUwpTextScaleFactorChanged() override;
   void OnUwpTextScaleFactorCleanup(UwpTextScaleFactor* source) override;
 
-  // Tests don't want to use the actual DPI settings of the monitor(s) on
-  // the machine running the test.
-  // Returns false if running in unit tests, if the ScreenWin constructor was
-  // called with initialize set to false.
-  bool PerProcessDPIAwarenessDisabledForTesting() const;
-
   // Helper implementing the DisplayObserver handling.
   DisplayChangeNotifier change_notifier_;
 
@@ -298,9 +288,6 @@ class DISPLAY_EXPORT ScreenWin : public Screen,
 
   base::ScopedObservation<UwpTextScaleFactor, UwpTextScaleFactor::Observer>
       scale_factor_observation_{this};
-
-  // Used to avoid calling GetSystemMetricsForDpi in unit tests.
-  bool per_process_dpi_awareness_disabled_for_testing_ = false;
 
   // Used to track if primary_monitor_ changes, which is used as a signal that
   // screen_win_displays_ needs to be updated. This should be updated when
diff --git a/ui/views/win/hwnd_message_handler.cc b/ui/views/win/hwnd_message_handler.cc
index 26936fe6bd51f..22bb24f2afcef 100644
--- a/ui/views/win/hwnd_message_handler.cc
+++ b/ui/views/win/hwnd_message_handler.cc
@@ -453,7 +453,8 @@ void HWNDMessageHandler::Init(HWND parent,
 // HWNDMessageHandler, private:
 
 void HWNDMessageHandler::InitExtras() {
-  if (!called_enable_non_client_dpi_scaling_ && delegate_->HasFrame()) {
+  if (!called_enable_non_client_dpi_scaling_ && delegate_->HasFrame() &&
+      base::win::IsProcessPerMonitorDpiAware()) {
     // Derived signature; not available in headers.
     // This call gets Windows to scale the non-client area when
     // WM_DPICHANGED is fired.
@@ -2341,7 +2342,7 @@ LRESULT HWNDMessageHandler::OnNCCalcSize(BOOL mode, LPARAM l_param) {
 
 LRESULT HWNDMessageHandler::OnNCCreate(LPCREATESTRUCT lpCreateStruct) {
   SetMsgHandled(FALSE);
-  if (delegate_->HasFrame()) {
+  if (delegate_->HasFrame() && base::win::IsProcessPerMonitorDpiAware()) {
     using EnableNonClientDpiScalingPtr = decltype(::EnableNonClientDpiScaling)*;
     static const auto enable_non_client_dpi_scaling_func =
         reinterpret_cast<EnableNonClientDpiScalingPtr>(
