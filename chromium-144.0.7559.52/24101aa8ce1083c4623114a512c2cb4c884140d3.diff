diff --git a/chrome/installer/util/lzma_util.cc b/chrome/installer/util/lzma_util.cc
index 0a2ab5373fa8d..f53810a95f908 100644
--- a/chrome/installer/util/lzma_util.cc
+++ b/chrome/installer/util/lzma_util.cc
@@ -14,16 +14,12 @@
 #include <ntstatus.h>
 #include <stddef.h>
 
-#include <memory>
 #include <set>
-#include <utility>
 
-#include "base/containers/span.h"
 #include "base/files/file_util.h"
+#include "base/files/memory_mapped_file.h"
 #include "base/logging.h"
 #include "base/memory/raw_ptr.h"
-#include "base/types/expected_macros.h"
-#include "chrome/installer/util/unbuffered_file_writer.h"
 #include "third_party/lzma_sdk/google/seven_zip_reader.h"
 
 namespace {
@@ -56,10 +52,8 @@ class SevenZipDelegateImpl : public seven_zip::Delegate {
 
   std::set<base::FilePath> directories_created_;
   std::optional<DWORD> error_code_;
-
-  // The file to which the current entry will be written.
-  std::optional<installer::UnbufferedFileWriter> current_file_;
-
+  base::File current_file_;
+  std::optional<base::MemoryMappedFile> mapped_file_;
   UnPackStatus unpack_error_ = UNPACK_NO_ERROR;
 };
 
@@ -151,18 +145,39 @@ bool SevenZipDelegateImpl::OnEntry(const seven_zip::EntryInfo& entry,
 
   CreateDirectory(file_path.DirName());
 
-  ASSIGN_OR_RETURN(
-      current_file_,
-      installer::UnbufferedFileWriter::Create(file_path, entry.file_size),
-      [this](DWORD error) {
-        error_code_ = error;
-        PLOG(ERROR) << "Invalid file";
-        unpack_error_ = UNPACK_CREATE_FILE_ERROR;
-        return false;
-      });
+  current_file_ =
+      base::File(file_path, base::File::FLAG_CREATE_ALWAYS |
+                                base::File::FLAG_READ | base::File::FLAG_WRITE |
+                                base::File::FLAG_WIN_EXCLUSIVE_READ |
+                                base::File::FLAG_WIN_EXCLUSIVE_WRITE |
+                                base::File::FLAG_CAN_DELETE_ON_CLOSE |
+                                base::File::FLAG_WIN_SHARE_DELETE);
+  if (!current_file_.IsValid()) {
+    PLOG(ERROR) << "Invalid file";
+    error_code_ = ::GetLastError();
+    unpack_error_ = UNPACK_CREATE_FILE_ERROR;
+    return false;
+  }
 
-  // Return a view into the writer's output buffer.
-  output = current_file_->write_buffer().first(entry.file_size);
+  // The target file is deleted by default unless extracting succeeds.
+  current_file_.DeleteOnClose(true);
+
+  if (entry.file_size > 0) {
+    mapped_file_.emplace();
+    bool mapped_file_ok = mapped_file_->Initialize(
+        current_file_.Duplicate(), {0, static_cast<size_t>(entry.file_size)},
+        base::MemoryMappedFile::READ_WRITE_EXTEND);
+    if (!mapped_file_ok) {
+      PLOG(ERROR) << "Can't map file to memory";
+      error_code_ = ::GetLastError();
+      unpack_error_ = UNPACK_ALLOCATE_ERROR;
+      return false;
+    }
+
+    output = base::span<uint8_t>(mapped_file_->data(), mapped_file_->length());
+  } else {
+    output = base::span<uint8_t>();
+  }
 
   // Clear the last error code before the entry is extracted to reduce the
   // likelihood that it will hold an unrelated error code in case extraction
@@ -175,8 +190,8 @@ bool SevenZipDelegateImpl::OnEntry(const seven_zip::EntryInfo& entry,
 bool SevenZipDelegateImpl::EntryDone(seven_zip::Result result,
                                      const seven_zip::EntryInfo& entry) {
   // Take ownership of `current_file_` so that it is always closed when this
-  // function exits
-  auto current_file = *std::move(current_file_);
+  // function exits.
+  base::File current_file = std::move(current_file_);
 
   if (result != seven_zip::Result::kSuccess) {
     auto error_code = ::GetLastError();
@@ -209,26 +224,35 @@ bool SevenZipDelegateImpl::EntryDone(seven_zip::Result result,
         break;
     }
 
+    mapped_file_.reset();
     return false;
   }
 
-  // The writer's buffer now holds the entire entry.
-  current_file.Advance(entry.file_size);
-
-  // Commit the file, which sizes it appropriately and sets the last-modified
-  // time.
-  // TODO(crbug.com/394631579): Monitor UnbufferedFileWriter error metrics to
-  // see if/what errors are happening in the field. Consider using a retry loop
-  // here based on the data.
-  RETURN_IF_ERROR(current_file.Commit(entry.last_modified_time.is_null()
-                                          ? std::nullopt
-                                          : std::optional<base::Time>(
-                                                entry.last_modified_time)),
-                  [this](DWORD error) {
-                    error_code_ = error;
-                    unpack_error_ = UNPACK_EXTRACT_ERROR;
-                    return false;
-                  });
+  if (mapped_file_) {
+    // Modified pages are not written to disk until they're evicted from the
+    // working set. Explicitly kick off the write to disk now
+    // (asynchronously) to improve the odds that the file's contents are
+    // on-disk when another process (such as chrome.exe) would like to use
+    // them.
+    ::FlushViewOfFile(mapped_file_->data(), 0);
+    // Unmap the target file from the process's address space.
+    mapped_file_.reset();
+    // Flush to avoid odd behavior, such as the bug in Windows 7 through
+    // Windows 10 1809 for PE files described in
+    // https://randomascii.wordpress.com/2018/02/25/compiler-bug-linker-bug-windows-kernel-bug/.
+    // We've also observed oddly empty files on other Windows versions, so
+    // this is unconditional.
+    current_file.Flush();
+  }
+
+  // On success, `current_file` is kept.
+  current_file.DeleteOnClose(false);
+
+  if (!entry.last_modified_time.is_null()) {
+    FILETIME filetime = entry.last_modified_time.ToFileTime();
+    // Make a best-effort attempt to set the file time.
+    SetFileTime(current_file.GetPlatformFile(), nullptr, nullptr, &filetime);
+  }
 
   return true;
 }
